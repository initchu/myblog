# 2 类型断言

## 需求分析
**第一个例子：**

```go
package main
type Usber interface{ //接口和它的两个没有实现的方法
    Start()
    Stop()
}
type Phone struct{
}

func (p Phone) Start(){ //程序员1写的方法
	fmt.Println("手机开始工作。。")
}
func (p Phone) Stop(){//程序员2写的方法
	fmt.Println("手机停止工作。。")
}

type Computer struct{
} 
//定义个电脑类

func (c Computer) Working(usb Usber){ //电脑的方法是调用接口
    usb.Start()
    usb.Stop()
    usb.Call()
}
func main(){
    computer := Computer{} //电脑
    phone := Phone{} //手机
    computer.Working(phone) //电脑和手机工作
}
```

在这个例子中，如果我们的结构体`Phone`有一个方法是`Call()`，那么如果我们直接用电脑调用`usb.Call()`会产生<font style="color:#E8323C;">报错</font>。

**第二个例子：**

```go
type Point struct{
	x int
    y int
}
func main(){
    var a interface{}
    var point Point{1,2}
    a = point //空接口可以接收任意一个变量
    
    //如何将a赋给一个Point变量？
    var b Point
    b = a //可以吗? No.
    fmt.Println(b)
}
```

如何将一个接口变量，赋给自定义类型的变量。

## 类型断言Assert
```go
type Point struct{
	x int
    y int
}
func main(){
    var a interface{}
    var point Point{1,2}
    a = point //空接口可以接收任意一个变量
    
    //如何将a赋给一个Point变量？
    var b Point
    b = a.(Point)//类型断言
    fmt.Println(b)
}
```

`b = a.(Point)` 表示判断a是否指向Point类型的变量，如果是就转成Point类型并赋给b变量，否则<font style="color:#E8323C;">报错</font>。

类型断言的其他案例：

```go
func main(){
    var x interface{}
    var b float32 = 1.1
    x = b
    y := x.(float32) //除了float32的类型就会报错
    fmt.Println("y的类型是%T，值是%v")
}
    
```

**注：进行类型断言的时候，如果类型不匹配，就会报panic，因此进行类型断言的时候，要确保原来的空接口指向的就是断言的类型。**在进行类型断言的时候，添加如下检查机制：

```go
func main(){
    var x interface{}
    var b float32 = 1.1
    x = b
   if y,ok := x.(float); ok{
       fmt.Println("y的类型是%T，值是%v")
   } else{
    	fmt.Println("convert fail")
	}
}
```

## 案例分析
```go
package main
type Usber interface{ //接口和它的两个没有实现的方法
    Start()
    Stop()
}
type Phone struct{
}

func (p Phone) Start(){ //程序员1写的方法
	fmt.Println("手机开始工作。。")
}
func (p Phone) Stop(){//程序员2写的方法
	fmt.Println("手机停止工作。。")
}

type Computer struct{
} 
//定义个电脑类

func (c Computer) Working(usb Usber){ //电脑的方法是调用接口
    usb.Start()
    if phone, ok := usb.(Phone);ok{ //类型断言
        phone.Call()
    }
    usb.Stop()
}
func main(){
    var usbArr [3]Usb
    usbArr[0] = Phone{"vivo"}
    usbArr[1] = Phone{"小米"}
    usbArr[2] = Camera{"尼康"}
    var computer Computer
    for _,v := range usbArr{
        computer.Working(v)
        fmt.Println()
    }
}
```

案例2：判断输入的类型

```go
package main
func TypeJudge(item ...interface{}){
    for index, x := range items{
        switch x.(type){//（type）是固定写法
            case bool:
            	fmt.Printf("第%v个参数是bool类型%v",index,x)
            case float64:
            	fmt.Printf("第%v个参数是float64类型%v",index,x)
            case int, int32, int64:
            	fmt.Printf("第%v个参数是int类型%v",index,x)
            case string:
            	fmt.Printf("第%v个参数是string类型%v",index,x) 
            default:
            	fmt.Printf("第%v个参数是 类型不确定%v",index,x) 
        }
    }
}

func main(){
 	var n1 float64 = 1.1
    var n2 int32 = 30
    var name string = "syt"
    TypeJudge(n1, n2, name)
}
```



> 更新: 2022-05-02 09:49:24  
> 原文: <https://www.yuque.com/xiaoshan_wgo/codingnotes/snn9pb>