# 七大排序

## 冒泡排序
```go
func BubbleSort(data []int) {
    for i := 0; i < len(data); i++ {
        for j := 0; j < len(data)-i-1; j++ {
            if data[j] > data[j+1] {
                data[j], data[j+1] = data[j+1], data[j]
            }
        }
    }
    fmt.Printf("Result Data:%d\n", data)
}
```

## 插入排序
```go
func InsertSort(data []int) {
    fmt.Println("InsertSort")
    fmt.Printf("Source Data:%d\n", data)

    for i := 1; i < len(data); i++ {
        if data[i] < data[i-1] {
            for j := i; j > 0; j-- {
                if data[j] < data[j-1] {
                    data[j-1], data[j] = data[j], data[j-1]
                }
            }
        }
        fmt.Printf("Middle Data:%2d=>%d\n", i, data)
    }

    fmt.Printf("Result Data:%d\n", data)
}
```

## 选择排序
```go
func SelectSort(data []int) {
    fmt.Println("SelectSort")
    fmt.Printf("Source Data:%d\n", data)
    for i := 0; i < len(data); i++ {
        for j := i + 1; j < len(data); j++ {
            if data[i] > data[j] {
                data[j], data[i] = data[i], data[j]
            }
        }
        fmt.Printf("Middle Data:%2d=>%d\n", i, data)
    }
    fmt.Printf("Result Data:%d\n", data)
}

```

## 希尔排序
```go
func ShellSort(a []int) {
    n := len(a)
    h := 1
    for h < n/3 { //寻找合适的间隔h
        h = 3*h + 1
    }
    for h >= 1 {
        //将数组变为间隔h个元素有序
        for i := h; i < n; i++ {
            //间隔h插入排序
            for j := i; j >= h && a[j] < a[j-h]; j -= h {
                swap(a, j, j-h)
            }
        }
        h /= 3
    }
}
 
func swap(slice []int, i int, j int) {
    slice[i], slice[j] = slice[j], slice[i]
}
```

## 快速排序
```go
func quickSort(data []int) {
	if len(data) <= 1 {
		return
	}
	base := data[0]
	l, r := 0, len(data)-1
	for i := 1; i <= r; {
		if data[i] > base {
			data[i], data[r] = data[r], data[i]
			r--
		} else {
			data[i], data[l] = data[l], data[i]
			l++
			i++
		}
	}
	quickSort(data[:l])
	quickSort(data[l+1:])
}

func main() {
	s := make([]int, 0, 16)
	for i := 0; i < 16; i++ {
		s = append(s, rand.Intn(100))
	}
	fmt.Println(s)
	quickSort(s)
	fmt.Println(s)
}
```

## 归并排序
```go
func mergeSort(data []int) []int {
	length := len(data)
	if length <= 1 {
		return data
	}
	num := length / 2
	left := mergeSort(data[:num])
	right := mergeSort(data[num:])
	return merge(left, right)
}

func merge(left, right []int) (result []int) {
	l, r := 0, 0
	for l < len(left) && r < len(right) {
		if left[l] < right[r] {
			result = append(result, left[l])
			l++
		} else {
			result = append(result, right[r])
			r++
		}
	}
	result = append(result, left[l:]...)
	result = append(result, right[r:]...)
	return
}

func main() {
	s := make([]int, 0, 16)
	for i := 0; i < 16; i++ {
		s = append(s, rand.Intn(100))
	}
	fmt.Println(s)
	s = mergeSort(s)
	fmt.Println(s)
}
```

## 堆排序
```go
func heapSort(array []int) {
	m := len(array)
	s := m / 2
	for i := s; i > -1; i-- {
		heap(array, i, m-1)
	}
	for i := m - 1; i > 0; i-- {
		array[i], array[0] = array[0], array[i]
		heap(array, 0, i-1)
	}
}
func heap(array []int, i, end int) {
	l := 2*i + 1
	if l > end {
		return
	}
	n := l
	r := 2*i + 2
	if r <= end && array[r] > array[l] {
		n = r
	}
	if array[i] > array[n] {
		return
	}
	array[n], array[i] = array[i], array[n]
	heap(array, n, end)
}
func main() {
	s := make([]int, 0, 16)
	for i := 0; i < 16; i++ {
		s = append(s, rand.Intn(100))
	}
	fmt.Println(s)
	heapSort(s)
	fmt.Println(s)
}
```



> 更新: 2022-04-22 19:21:47  
> 原文: <https://www.yuque.com/xiaoshan_wgo/codingnotes/ggdz5g>