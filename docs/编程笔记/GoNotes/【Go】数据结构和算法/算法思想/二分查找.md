# 二分查找

## 二分查找解题模板
注：数组有序无重复。

查找的过程根据边界条件分为两种情况进行考虑：

+ **左闭右闭**
+ **左闭右开**

```go
package main

import "fmt"
//有一组升序排好序的数
func binarySearch(a []int,val int) (bool,int){
	left := 0
	right := len(a) - 1 //右边最后一个值的索引位置，mid的区间是左闭右闭。
	//right := len(a) 这时候取得的left和right的下标为要进行改变，mid在左闭右开的区间上进行查找
	for{
		if left > right{
			break
		}
	mid := left + (right - left) / 2
	if a[mid] > val{
		right = mid - 1 //中间值太大那就在左边进行查找
		//right = mid
	}
	if a[mid]< val{
		left = mid + 1 //中间值太小就继续往右边进行查找
	}else{
		return true,mid
		}
	}
	return false,-1
}

func main() {
	val := 5
	a := []int{1,2,3,4,5,6,7,8}
	//fmt.Println(len(a))
	isSearch,index := binarySearch(a,val)
	fmt.Println(isSearch,index)
}


```

在这两种情况中，因为左边永远是闭区间，所以在左指针调整位置的时候（升序情况下，中间值要小于要查找的值，所以在右区间查找），永远都调整到中间值的后一位进行查找，这是因为，中间值已经被判断过不等于查找的值`val`，所以要从`mid+1`开始向后查找。

同理，在右指针调整位置的情况下，要考虑最开始的`right`定义。如果`right = 长度-1`，那么可以说这个`mid`可以取到的最右边的位置是`a[mid] = a[ 长度-1 ]`，由于数组是从0记录开始的，所以这个索引值`mid`当为`right`的时候是可以被取到的，故为左闭右闭。如果`right`为长度，这个`right`值不应该被`mid`取到，因为超出了数组范围，故被称作右开，因为`mid`是开区间没有被搜索到，所以在左区间搜索的情况下，`right`更新的值应该为`mid`。



## 递归写法
```go
package main

import "fmt"
//有一组升序排好序的数

func binarySearch(nums []int, low int, high int, target int) int {
	if low > high {
		return -1
	}
	mid := (low + high ) / 2
	if nums[mid] == target {
		return mid
	} else if nums[mid] > target {
		return binarySearch(nums, low, mid - 1, target)
	} else {
		return binarySearch(nums, mid + 1, high, target)
	}
}
func search(nums []int, target int) int {
	return binarySearch(nums, 0, len(nums) - 1, target)
}


func main() {
	val1 := 5
	val2 := 9
	a := []int{1,2,3,4,5,6,7,8}
	//fmt.Println(len(a))
	isSearch,index := binary_Search(a,val1)
	fmt.Println(isSearch,index) //true 4
	ret := search(a,val2)
	fmt.Println(ret) //-1
}

```

## 参考文章
[https://www.cnblogs.com/kyoner/p/11080078.html](https://www.cnblogs.com/kyoner/p/11080078.html)



> 更新: 2022-01-05 20:39:30  
> 原文: <https://www.yuque.com/xiaoshan_wgo/codingnotes/rxhl6s>