# 树的实现

将数组切片转化为二叉树结构体:

```go

package main

import (
   "fmt"
)
//定义二叉树结构体
type binaryTree struct {
   value int
  leftNode *binaryTree
  rightNode *binaryTree
}

func main(){
   //0代表节点为空
  num := []int{1,2,3,4,5,0,6}
  //将数组切片转化为二叉树结构体
  tree := createBinaryTree(0,num)
   //二叉树数据
  var front []int
  front = frontForeach(*tree,front)
   fmt.Println(front)
}

//创建二叉树
func createBinaryTree(i int,nums []int) *binaryTree {
   tree := &binaryTree{nums[i], nil, nil}
   //左节点的数组下标为1,3,5...2*i+1
  if i<len(nums) && 2*i+1 < len(nums) {
      tree.leftNode = createBinaryTree(2*i+1, nums)
   }
   //右节点的数组下标为2,4,6...2*i+2
  if i<len(nums) && 2*i+2 < len(nums) {
      tree.rightNode = createBinaryTree(2*i+2, nums)
   }
   return tree
}

//前序遍历
func frontForeach(tree binaryTree,num []int) []int{
   //先遍历根节点
  if tree.value != 0 {
      num = append(num,tree.value)
   }
   var leftNum,rightNum []int
  //若存在左节点，遍历左节点树
  if tree.leftNode != nil {
      leftNum = frontForeach(*tree.leftNode,leftNum)
      for _,value := range leftNum{
         num = append(num,value)
      }
   }
   //若存在右节点，遍历右节点树
  if tree.rightNode != nil {
      rightNum = frontForeach(*tree.rightNode,rightNum)
      for _,value := range rightNum{
         num = append(num,value)
      }
   }

   return num
}
```

# 树的定义
```go
package tree

import "fmt"

type Node struct{
	Value int
	Left, Right *Node
}
func (node *Node) SetValue(value int){
	if node == nil{
		fmt.Println("Setting value to nil node. Ignore.")
		return
	}
	node.Value = value
}
func (node Node) Print(){ //定义方法 print()是给node来接收的
	//fmt.Print(node.value)
	fmt.Print(node.Value," ")
}
```

在 main中初始化树的操作：

```go
package main

import (
	"fmt"
	"go_module/tree"
)
type myTreeNode struct {
	*tree.Node // Embedding 内嵌 语法糖可以直接让后面的节点省略一些代码
}
func main() {
	var root tree.Node
	fmt.Println(root)
	root = tree.Node{Value: 3}
	root.Left = &tree.Node{}
	nodes := []tree.Node{
		{Value: 3},
		{},
		{6,nil,&root},
	}
	fmt.Println(nodes)
	root.Print()//方法，传值
	var pRoot *tree.Node
	pRoot.SetValue(200)
	pRoot = &root
	pRoot.SetValue(300)
	pRoot.Print()
	root.Traverse()
	//值接收者是go特有的
}
```

# 树的遍历
```go
func (myNode *myTreeNode) postOrder(){
	if myNode == nil || myNode.Node == nil{
		return
	}
	left := myTreeNode{myNode.Left}
	left.postOrder()
	right := myTreeNode{myNode.Right}
	right.postOrder()
	myNode.Print()
}

```

```go

func levelOrder(root *TreeNode) [][]int {
    ret := [][]int{}
    if root == nil {
        return ret
    }
    q := []*TreeNode{root}
    for i := 0; len(q) > 0; i++ {
        ret = append(ret, []int{})
        p := []*TreeNode{}
        for j := 0; j < len(q); j++ {
            node := q[j]
            ret[i] = append(ret[i], node.Val)
            if node.Left != nil {
                p = append(p, node.Left)
            }
            if node.Right != nil {
                p = append(p, node.Right)
            }
        }
        q = p
    }
    return ret
}
```



> 更新: 2022-12-01 14:01:53  
> 原文: <https://www.yuque.com/xiaoshan_wgo/codingnotes/pdy8i1>