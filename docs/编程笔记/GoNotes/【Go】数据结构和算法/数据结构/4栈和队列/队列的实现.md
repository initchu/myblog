# 队列的实现

## 数组模拟队列的思想
队列本身是有序列表，如果使用数组的结构来存储队列的数据，则队列数组的声明如下：

```go
type Queue struct{
    maxSize int 
    array [3]int
    front int
    rear int
}
```

其中的`MaxSize`是该队列的最大容量。因为队列的输出、输入是分别从前后端来进行处理的，因此需要两个变量`front`及`rear`分别记录队列前后端的下标，`front`会随着数组的输出而发生改变，而`rear`则是随着数据的输入而改变。

当我们将数据存入队列时，将函数定义为`addqueue`，入队一般有两个步骤：

（1）将尾指针后移：`rear+1`，当`front == rear`时候，意味着队列为空；

（2）若尾指针`rear`小于等于队列的最大下标`MaxSize-1`，则将数据存入`rear`所指向的数组元素中，否则无法存入数据，当`rear== MaxSize-1`意味着队列满。

## 非环形队列
```go
package main

import (
	"errors"
	"fmt"
)

// Queue 含头节点
type Queue struct {
	maxSize int
	array [5]int //模拟队列的数组
	front int //队尾
	rear int //队首
}

// AddQueue 添加数据到队列
func (this *Queue) AddQueue(val int)(err error){
	//判断队列是否满
	if this.rear == this.maxSize - 1{
		return errors.New("queue full")
	}
	this.rear ++ //rear后移
	this.array[this.rear] = val
	return
}

//出队列

func(this *Queue)  GetQueue() (val int ,err error){
	//判断是否为空
	if this.rear == this.front{
		return -1,errors.New("queue empty")
	}
	this.front ++
	val = this.array[this.front]
	return val,errors.New("无错误")
	
} 

// ShowQueue 显示队列,找到队首，然后遍历到队尾
func (this *Queue) ShowQueue(){
	fmt.Println("队列当前的元素是")
	for i := this.front + 1 ; i <= this.rear;i++{
		fmt.Printf("array[%d] = %d\t",i,this.array[i])
	}//不包含头节点
	fmt.Println()
}

func main() {
	queue := & Queue{
		maxSize: 5,
		front: -1,
		rear:-1,
	}
	var key string
	var val int
	for{
		fmt.Println("1.输入add表示添加数列到队列")
		fmt.Println("2.输入get表示从队列获取数据")
		fmt.Println("3.输入show表示显示队列")
		fmt.Println("4.输入exit表示退出队列")
		fmt.Scanln(&key)
		switch key {
		case "add":
			fmt.Println("输入你要输入的队列：")
			fmt.Scanln(&val)
			err := queue.AddQueue(val)
			if err != nil{
			//
			}
		}
	}
}
```

测试代码省略了：

编码思路：给队列定义一个结构体，然后给这个结构体添加CRUD的方法，在主函数测试过程中，实例化一个结构体变量，然后调用方法。

添加一个元素，删除一个元素，这个头指针后移，当头指针和尾指针相等的时候，队列即使是空的，也不能进行添加了，因为队列的头指针已经移动到了这个数组最后的位置，不能再往里面加了，为了解决这个问题，环形队列出现了。

## 环形队列
循环队列的一个好处是我们可以利用这个队列之前用过的空间。

在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

每次 `rear` 队首的指针到队列的最后一位的时候，这个指针加一取模就变成了头指针。



**注**：相比于非环形队列。尾索引的下一个为头索引时候表示队满，即将队列容量空出一个作为约定，`tail + 1 % MaxSize == head`为队满。他的尾部和头部`tail == head`相等的时候为空。

初始化的时候，tail和head都为0，这意味着都在这个队列的最前面。统计该队列有多少个元素的时候`(tail + maxSize - head) % maxSize`。

















> 更新: 2022-01-08 21:52:08  
> 原文: <https://www.yuque.com/xiaoshan_wgo/codingnotes/gpla2g>