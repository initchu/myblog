# 逃逸分析

# 基本概念和作用
在编译原理中，分析指针动态范围变化的方法被称为逃逸分析。

当一个对象的指针被多个方法或线程引用时，则称这个指针发生了**逃逸**。

**逃逸分析**决定一个变量是分配在**堆**上还是分配在**栈**上。

**逃逸分析的作用：**

<u>逃逸分析把变量合理的分配到它该去的地方（找准自己的位置）。通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会</u>**<u>减轻内存分配的开销</u>**<u>，同时也会</u>**<u>减少垃圾回收的压力</u>**<u>，</u>**<u>提高程序的运行速度</u>**<u>。</u>

# 逃逸分析的原则
Go 语言逃逸分析的基本原则是：<u>如果一个函数的返回对一个变量的引用，那么这个变量就会发生逃逸。</u>

编译器会分析代码的特征和代码的生命周期，Go 中的变量只有在编译器可以证明在函数返回后<u>不会</u>再被引用的，才会被分配到栈上，其他的情况下都是分配到堆上。

总结：

1. 如果变量在函数外部没有被引用，则**优先**放到栈上。（例外，如果定义了一个很大的数组，需要申请的内存过大，**超过了栈的存储能力**，则放到堆上。）
2. 如果变了在函数外部存在引用，则**必定**放在堆上。

# 如何确定是否发生逃逸
如何确定发生逃逸，就是如何确定这个指针/变量在堆上。

命令：

`go build -gcflags '-m -l' main.go`

-gcflags 参数是用于启用编译器支持的额外标志。

-m 用于输出编译器的优化细节（包括使用逃逸分析这种优化），相反想要关闭优化则使用 -N。

-l 用于禁用内联优化，防止逃逸被编译器通过内联彻底的抹除。

[Go 内联优化：如何让我们的程序更快？_煎鱼（EDDYCJY）的博客-CSDN博客](https://blog.csdn.net/EDDYCJY/article/details/125383360)

**<font style="color:rgb(77, 77, 77);">内联是将较小的函数合并到它们各自的调用者中的行为。</font>**

**<font style="color:rgb(77, 77, 77);">Go 编译器在某些条件下通过用函数的内容替换对函数的调用来做到这一点，这被称为内联。</font>**

[垃圾回收机制]( https://www.yuque.com/xiaoshan_wgo/gonotes/evi3g1#xMiLr)

# 与 C++ 对比，Go 的优势
在写 C++ 的时候，为了提高效率，会讲返回值修改为指针，避免构造函数的开销。如果在函数内部定义了一个局部变量，函数结束的时候返回这个局部变量的地址，因为这些局部变量是在栈上进行分配（静态内存分配）的，函数一旦执行完毕，变量占据的内存空间就会被销毁，所以会导致程序直接的崩溃。例如：

```cpp
int *foo(){
	int t = 3;
    return &t;
}
```

一些常见的改进：

```cpp
int *foo(){
	int *t = new int;
    *t = 3;
    return t;
}
```

新建出来的对象该在何时何地删除呢，调用者可能会忘记删除或者直接将返回值传给了其他的函数，之后就再也不能删除他了，也就发生了所谓的内存泄漏。Go 语言编译器的逃逸分析就不会造成这种现象。这也是 Go 语言的优势。

# 参考链接
[逃逸分析是怎么进行的](https://golang.design/go-questions/compile/escape/)



> 更新: 2022-11-07 17:15:22  
> 原文: <https://www.yuque.com/xiaoshan_wgo/codingnotes/yuzkap>