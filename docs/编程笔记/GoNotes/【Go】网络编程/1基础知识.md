# 1 基础知识

## 网络协议的概念


从应用的角度出发，协议可理解为“规则”，是数据传输和数据的解释的规则。



> 假设， A、B双方欲传输文件。规定：
>
> + 第一次，传输文件名，接收方接收到文件名，应答OK给传输方；
> + 第二次，发送文件的尺寸，接收方接收到该数据再次应答一个OK；
> + 第三次，传输文件内容。同样，接收方接收数据完成后应答OK表示文件内容接收成功。
>



由此，无论A、B之间传递何种文件，都是通过三次数据传输来完成。A、B之间形成了一个最简单的数据传输规则。双方都按此规则发送、接收数据。A、B之间达成的这个相互遵守的规则即为协议。

这种仅在A、B之间被遵守的协议称之为**原始协议**。

当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个**标准协议**。

## 网络的分层模型
为了减少协议设计的复杂性，大多数网络模型均采用分层的方式来组织。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。每一层利用下一层提供的服务来为上一层提供服务，本层服务的实现细节对上层屏蔽。

[1 OSI七层模型和TCP/IP四层模型](https://www.yuque.com/xiaoshan_wgo/basic/ogzdx0#WP5EB)

网络的每一层，都定义了很多协议。这些协议的总称，叫“TCP/IP 协议”。TCP/IP 协议是一个大家族，不仅仅只有 TCP 和 IP 协议，它还包括其它的协议。IP

## IP 端口
如果把IP地址比作一间房子，端口就是出入这间房子的门，真正的房子只有几个门，但是一个IP地址的端口号可以有65536个，端口使用端口号来标记的，端口号只有整数，范围是0到65535。

**0是保留端口**

**1-1024是固定端口：**

22：SSH远程登陆协议

23：telnet使用

21：ftp使用

25：smtp服务使用

80：iis使用

7：echo服务

**1025-65535是动态端口：**

3306：mysql默认端口

****

`**ipconfig**`**查询**`**IP**`**地址。**

注意要点：

1. 只要是做服务程序，都必须**监听**一个端口
2. 该端口就是其他程序和该服务通讯的通道
3. 一台电脑有65535个端口
4. 一旦一个端口被某个程序监听（占用），那么其他的程序就不能在该端口监听了

计算机尽可能少开端口，一个端口只能被一个程序监听，如果使用`netstat -an`可以查看本机有哪些端口被监听。

# HTTP 协议基础
+ http：超文本传输协议 Hyper Text Transfer Protocol
+ http 属于应用层协议，它在传输层用的是 tcp 协议
+ 无状态，对事物处理没有记忆功能（对比 TCP 协议里面的确认号）如果要保存状态需要引用其他技术，如cookie
+ 无连接，每次连接只处理一个请求。后来通过keep-alive实现了长连接

## 格式
![1654004416063-7db3c12e-9468-44cd-b8e5-3b39dd0524b6.png](./img/f3l5eD1oAVHGseTH/1654004416063-7db3c12e-9468-44cd-b8e5-3b39dd0524b6-134251.png)

![1654004424480-fab2b6a3-c096-42f3-93c2-a65f24001308.jpeg](./img/f3l5eD1oAVHGseTH/1654004424480-fab2b6a3-c096-42f3-93c2-a65f24001308-591970.jpeg)

```plain
POST /post?id=1234&page=1 HTTP/1.1
Content-Type:application/x-www-form-urlencoded

name = manu&message=this_is_great
```

## 请求正文
GET 请求没有请求正文。

## 请求方法
| **GET** | **请求获取 Request-URI 所标识的资源** |
| :---: | :---: |
| **POST** | **向 URI 提交数据（例如表单或上传数据）** |
| **HEAD** | **类似于 GET，返回的响应中没有具体的内容，用于获取报头** |
| **PUT** | **对服务器上已经存在的资源进行更新** |
| **DELETE** | **请求服务器删除指定的页面** |
| **CONNECT** | **HTTP /1.1 预留，能够将连接改为管道方式的代理服务器** |
| **OPTIONS** | **查看服务端性能** |
| **TRACE** | **回显服务器收到的请求，主要用于测试或者诊断** |
| **PATCH** | **同 PUT，可只对资源的一部分进行更新，资源不存在时会创建** |


黄色：HTTP 1.0

蓝色：HTTP 1.1

## URL 相关内容
URI（uniform resource identifier）：统一资源定位符，用来唯一的标识一个资源

URL（uniform resource locator）： 统一资源定位器，是一种具体的 URI，指明了如何 locate 这个资源

## 请求头
| **Header** | **解释** | **示例** |
| :---: | :---: | :---: |
| Accept | 指定客户端能够接收的内容类型 | Accept: text/plain, text/html |
| Accept-Charset | 浏览器可以接受的字符编码集 | Accept-Charset: iso-8859-5 |
| Accept-Encoding | 指定浏览器可以支持的 web 服务器返回内容压缩编码类型 | Accept-Encoding: compress, gzip |
| Accept-Language | 浏览器可接收的语言 | Accept-Language: en, zh |
| Authorization | HTTP 授权的授权证书 | Authrization: Basic QWxhZGRnbjpbGVuIHNLc2FtZQ== |
| Cache-Control | 指定请求和响应遵循的缓存机制 | Cache-Control: no-chache |
| Cookie | HTTP 请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器 | Cookie: $Version=1; Skin=new; |
| Content-Length | 请求的内容长度 | Content-Length: 348 |
| Content-Type | 指定正文（Body）的数据格式 | Content-Type: application/x-www-form-urlencoded |
| User-Agent | 浏览器信息 | Mozilla/5.0(Windows NT 6.1; Win64; x86) |


## Content-Type
+ **application/x-www-form-urlencoded**
    - 浏览器的原生 form 表单，如果不设置 `Content-Type` 属性，则默认以` application/x-www-form-urlencoded` 方式传输数据
    - 正文例如：`name=manu&message=this_is_great`
+ **multipart/form-data**
    - 上传文件时使用 `multipart/form-data`, 支持多种文件格式
    - 正文例如：`name="text"name="file"; filename="chrome.png"Content-Type: image/png...content of chrome.png`
+ **application/json**
    - 正文例如：`{"title":"test","sub":[1,2,3]}`
+ **text/xml**
    - 正文例如：

```xml
<?xml version="1.0"?><methodCall>
  <methodName>examples.getStateName</methodName>
</methodCall>
```

## GET 和 POST 的区别
+ GET 的请求参数可以全部在 URL 里面，参数变时，URL 就变；post 可以把参数方到请求正文里面，参数变时候 URL 不变。
+ 虽然 HTTP 协议并没有对 URL 和请求正文做长度限制，但在实际中浏览器对 URL 的长度限制比请求正文要小很多，所以 POST 可以提交的数据比 GET 要大的多。
+ GET 比 POST 更容易收到攻击（源于 GET 的参数直接暴露在 URL 中）。

# Cookie、Session、Token
## Cookie
用户名和密码存在数据库中，每次登录都需要自己亲自输入用户名和密码。

在网页中，使用 Cookie 可以让浏览器记住密码，免去多次输入用户名和密码的过程。

但是直接存储并不够安全，于是出现了 Session 将用户名和密码进行加密。

## Session
用户名和密码发给服务器，服务器生成一串  Session ID 和会话结束时间，并把他们发送给浏览器，设置 Cookie, 会话结束时间就是 Cookie 的有效时间。但是如果有大量 ID 存储在服务器里面，可能就会崩溃。所以出现了JWT（JSON WEB TOKEN）。

## Token
<font style="color:rgb(64, 64, 64);">客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。</font>Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个Token 前来请求数据即可，无需再次带上用户名和密码。<font style="color:rgb(64, 64, 64);">使用Token的目的，Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</font>





> 更新: 2022-07-29 13:48:02  
> 原文: <https://www.yuque.com/xiaoshan_wgo/codingnotes/ko6n1g>