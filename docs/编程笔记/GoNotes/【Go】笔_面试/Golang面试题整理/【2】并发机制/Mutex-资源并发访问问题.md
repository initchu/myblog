# Mutex - 资源并发访问问题

并发访问问题是，当多个 goroutine 并发更新同一个资源，例如:

计数器；

同时更新用户的账户信息；

秒杀系统；

往同一个 buffer 中并发写入数据等。

如果没有互斥控制，就会出现一些异常:

计数器的计数不准确；

用户的账户出现透支；

秒杀系统出现超卖；

buffer 中的数据混乱。

解决这些问题，可以使用互斥锁（在 Go 中，就是 Mutex）。

## 互斥锁的实现机制
### 互斥锁的概念
概念：互斥锁是并发控制的一个手段，是为了避免竞争而建立的一种并发控制机制。有时候，互斥锁也叫排它锁。在 Go 中，Muetx 是使用最广泛的同步原语/并发原语（Synchronization primitives）。同步原语适用的场景有：

+ 共享资源。并发地读写共享资源，会出现数据竞争的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。
+ 任务编排。需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，常常使用 WaitGroup 或者 Channel 来实现。
+ 消息传递。信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。

### 临界区的概念
<u>在并发编程中，如果程序中的一部分会被并发访问或修改，为了避免并发访问导致的意外的结果，这部分程序需要被保护起来，这部分被保护起来的程序</u>，叫做**临界区**。

可以说，临界区是一个被<u>共享</u>的资源，或者说是一个整体的一组共享资源，比如对数据库的访问、对某一个共享数据结构的操作，对一个 I/O 设备的使用，对一个连接池中的连接的调用，等等。

如果很多线程同步访问临界区，就会造成访问或者操作错误，所以**使用互斥锁，限定临界区只能同时由一个线程持有**。

当临界区有一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待，直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区。

## Mutex 的基本使用方法
在 Go 的标准库中，package sync 提供了锁相关的一系列同步原语，这个 package 还定义了一个 Locker 的接口（实际项目中用的不多），Mutex 就实现了这个接口。Locker 的接口定义了锁同步原语的方法集：

```go
type Locker interface {
    Lock()
    Unlock()
}
```

有两个方法，一个是请求锁（Lock），另一个是释放锁（Unlock）。

**Mutex 就提供了两个方法 Lock 和 Unlock，进入临界区之前调用 Lock 方法，退出临界区的时候调用 Unlock 方法**：

```go
func(m *Mutex)Lock()
func(m *Mutex)Unlock()
```



> 更新: 2022-04-06 13:44:05  
> 原文: <https://www.yuque.com/xiaoshan_wgo/codingnotes/npwnyu>