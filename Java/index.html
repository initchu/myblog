
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="褚成志">
      
      
        <link rel="canonical" href="http://blog.chucz.asia/Java/">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>Java基础 - 褚成志的技术博客</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#java" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="褚成志的技术博客" class="md-header__button md-logo" aria-label="褚成志的技术博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            褚成志的技术博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Java基础
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="褚成志的技术博客" class="md-nav__button md-logo" aria-label="褚成志的技术博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    褚成志的技术博客
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    首页
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#java_1" class="md-nav__link">
    <span class="md-ellipsis">
      Java 的优势
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_2" class="md-nav__link">
    <span class="md-ellipsis">
      Java的特点
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java-c" class="md-nav__link">
    <span class="md-ellipsis">
      Java 与 C++ 的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      什么是值传递和引用传递？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java-c_1" class="md-nav__link">
    <span class="md-ellipsis">
      Java 和C++的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java-javasciprt" class="md-nav__link">
    <span class="md-ellipsis">
      比较一下Java 和JavaSciprt
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_3" class="md-nav__link">
    <span class="md-ellipsis">
      Java 语言有哪些特点
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象和面向过程的区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象和面向过程的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_4" class="md-nav__link">
    <span class="md-ellipsis">
      Java 面向对象编程三大特性: 封装 继承 多态
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象的特征有哪些方面?
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象有哪些特性？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象的特征有哪些方面
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象的特征
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      什么是多态
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      继承和多态的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_5" class="md-nav__link">
    <span class="md-ellipsis">
      Java 多态（乐视）
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_6" class="md-nav__link">
    <span class="md-ellipsis">
      Java 中实现多态的机制是什么？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_7" class="md-nav__link">
    <span class="md-ellipsis">
      谈谈对 java 多态的理解
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_8" class="md-nav__link">
    <span class="md-ellipsis">
      Java的四个基本特性（抽象、封装、继承，多态），对多态的理解(多态的实现方式)以及在项目中那些地方用到多态
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      面向对象和面向过程的区别？用面向过程可以实现面向对象吗？那是不是不能面向对象？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oop" class="md-nav__link">
    <span class="md-ellipsis">
      OOP是什么
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#javaoop" class="md-nav__link">
    <span class="md-ellipsis">
      Java(OOP)面向对象的三个特征与含义
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aop" class="md-nav__link">
    <span class="md-ellipsis">
      AOP是什么
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aopoop" class="md-nav__link">
    <span class="md-ellipsis">
      AOP与OOP的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#jdkjrejvm" class="md-nav__link">
    <span class="md-ellipsis">
      JDK、JRE、JVM
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#jdk" class="md-nav__link">
    <span class="md-ellipsis">
      JDK源码，了解哪些常用库
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#jvm-jdk-jre" class="md-nav__link">
    <span class="md-ellipsis">
      关于 JVM JDK 和 JRE 最详细通俗的解答
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#oracle-jdk-openjdk" class="md-nav__link">
    <span class="md-ellipsis">
      Oracle JDK 和 OpenJDK 的对比
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#jdkjre" class="md-nav__link">
    <span class="md-ellipsis">
      JDK和JRE的区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_9" class="md-nav__link">
    <span class="md-ellipsis">
      什么是Java 程序的主类应用程序？和小程序的主类有何不同？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_10" class="md-nav__link">
    <span class="md-ellipsis">
      Java 应用程序与小程序之间有那些差别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      引用数据类型
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      类、对象的概念
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_11" class="md-nav__link">
    <span class="md-ellipsis">
      Java创建对象有几种方式？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_12" class="md-nav__link">
    <span class="md-ellipsis">
      Java支持多继承吗？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      类可以继承多个类么？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      接口可以继承多个接口么？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      类可以实现多个接口么？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#constructor-override" class="md-nav__link">
    <span class="md-ellipsis">
      构造器 Constructor 是否可被 override
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#equals" class="md-nav__link">
    <span class="md-ellipsis">
      equals与==的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#equals_1" class="md-nav__link">
    <span class="md-ellipsis">
      ==和equals的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#equals_2" class="md-nav__link">
    <span class="md-ellipsis">
      == 与 equals(重要)
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hashcode-equals" class="md-nav__link">
    <span class="md-ellipsis">
      Hashcode（）和 equals（）和 == 区别?
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java-equals-hashcode" class="md-nav__link">
    <span class="md-ellipsis">
      java 中==和 equals 和 hashCode 的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java-equals-equals-hashcode" class="md-nav__link">
    <span class="md-ellipsis">
      Java 中==和 equals 的区别， equals 和 hashCode 的区别（乐视）
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#equals_3" class="md-nav__link">
    <span class="md-ellipsis">
      equals和==有什么区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#a-equals-hashmap-equals" class="md-nav__link">
    <span class="md-ellipsis">
      修改对象 A 的 equals 方法的签名，那么使用 HashMap 存放这个对象实例的时候，会调用哪个 equals 方法？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hashcode-equals_1" class="md-nav__link">
    <span class="md-ellipsis">
      hashCode 与 equals（重要）
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#object" class="md-nav__link">
    <span class="md-ellipsis">
      Object有哪些公用方法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#object_1" class="md-nav__link">
    <span class="md-ellipsis">
      Object常用方法有哪些？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hashcode" class="md-nav__link">
    <span class="md-ellipsis">
      hashcode的作用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#object_2" class="md-nav__link">
    <span class="md-ellipsis">
      Object类中有哪些方法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hashcode_1" class="md-nav__link">
    <span class="md-ellipsis">
      如何理解hashcode的作用
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hashcode_2" class="md-nav__link">
    <span class="md-ellipsis">
      为什么重写hashCode()方法？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#equals_4" class="md-nav__link">
    <span class="md-ellipsis">
      为什么重写equals()方法？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#overrideoverload" class="md-nav__link">
    <span class="md-ellipsis">
      Override和Overload的含义去区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      重载和重写的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#overloadoverride" class="md-nav__link">
    <span class="md-ellipsis">
      重载（Overload）和重写（Override）的区别，重载的方法能否根据返回类型进行区分?
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      方法重载和重写的区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#constructor" class="md-nav__link">
    <span class="md-ellipsis">
      何时用覆盖，何时用重载？构造器Constructor是否可被覆盖/重载？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      重载和重写，如何确定调用哪个函数？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      重载和重写的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      子类能否重写父类的静态方法
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      父类的静态方法能否被子类重写？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#constructoroverride" class="md-nav__link">
    <span class="md-ellipsis">
      构造器（constructor）是否可被重写（override）?
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java_13" class="md-nav__link">
    <span class="md-ellipsis">
      Java 访问修饰符权限的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#java-id" class="md-nav__link">
    <span class="md-ellipsis">
      Java 的序列化做什么用的？序列化id作用？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#javajava" class="md-nav__link">
    <span class="md-ellipsis">
      什么是java序列化，如何实现java序列化？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#aa1a2aa-x-new-a1a1-x1-xa2-x2-x" class="md-nav__link">
    <span class="md-ellipsis">
      假设A为一个基类，A1和A2都继承A。能不能写A x = new A1()？能不能写A1 x1 = x？能不能写A2 x2 = x？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#extends-super" class="md-nav__link">
    <span class="md-ellipsis">
      泛型中 extends 和 super 的区别
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="java">Java基础<a class="headerlink" href="#java" title="Permanent link">&para;</a></h1>
<h3 id="java_1">Java 的优势<a class="headerlink" href="#java_1" title="Permanent link">&para;</a></h3>
<ul>
<li>语法简单</li>
<li>跨平台</li>
<li>当开发规模膨胀到一定程度，Java在规范、协作和性能调优上还是占有很大优势,在大型应用，尤其是企业应用上，Java的地位仍然难以撼动</li>
</ul>
<h3 id="java_2">Java的特点<a class="headerlink" href="#java_2" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Java是一门面向对象的编程语言。</strong></li>
</ul>
<p>面向对象和面向过程的区别参考下一个问题。</p>
<ul>
<li><strong>Java具有平台独立性和移植性。</strong></li>
</ul>
<p>Java有一句口号： Write once, run anywhere ，一次编写、到处运行。这也是Java的魅力所在。而实现这种特性的正是Java虚拟机JVM。已编译的Java程序可以在任何带有JVM的平台上运行。你可以在windows平台编写代码，然后拿到linux上运行。只要你在编写完代码后，将代码编译成.class文件，再把class文件打成Java包，这个jar包就可以在不同的平台上运行了。</p>
<ul>
<li><strong>Java具有稳健性。</strong></li>
</ul>
<p>Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。</p>
<p>异常处理是Java中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用try/catch/finally 语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。</p>
<h3 id="java-c">Java 与 C++ 的区别<a class="headerlink" href="#java-c" title="Permanent link">&para;</a></h3>
<p>Java 是纯粹的面向对象语言，所有的对象都继承自java.lang.Object，C++ 兼容C ，不但支持面向对象也支持面向过程。</p>
<p>Java 通过虚拟机从而实现跨平台特性，C++ 依赖于特定的平台。</p>
<p>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</p>
<p>Java 支持自动垃圾回收，而 C++ 需要手动回收。</p>
<p>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</p>
<h3 id="_1">什么是值传递和引用传递？<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p>值传递是对基本型变量而言的,传递的是该变量的一个副本，改变副本不影响原变量。</p>
<p>引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身。所以对引用对象进行操作会同时改变原对象。</p>
<h3 id="java-c_1">Java 和C++的区别<a class="headerlink" href="#java-c_1" title="Permanent link">&para;</a></h3>
<p>****我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java 和C++ 比呀！没办法！！！就算没学过C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ul>
<h3 id="java-javasciprt">比较一下Java 和JavaSciprt<a class="headerlink" href="#java-javasciprt" title="Permanent link">&para;</a></h3>
<p>JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言，它的前身是LiveScript；而Java 的前身是Oak语言。</p>
<p>下面对两种语言间的异同作如下比较：</p>
<p>1）基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种<strong>基于对象（Object-Based）</strong>和<strong>事件驱动（Event-Driven）</strong>的编程语言。因而它本身提供了非常丰富的内部对象供设计人员使用；</p>
<p>2）解释和编译：Java 的源代码在执行之前，必须经过编译；JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行；</p>
<p>3）强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量声明，采用其弱类型。即变量在使用前不需作声明，而是解释器在运行时检查其数据类型；</p>
<p>4）代码格式不一样。</p>
<p>补充：上面列出的四点是原来所谓的标准答案中给出的。其实Java和JavaScript最重要的区别是一个是静态语言，一个是动态语言。目前的编程语言的发展趋势是函数式语言和动态语言。在Java中类（class）是一等公民，而JavaScript中函数（function）是一等公民。对于这种问题，在面试时还是用自己的语言回答会更加靠谱。</p>
<h3 id="java_3">Java 语言有哪些特点<a class="headerlink" href="#java_3" title="Permanent link">&para;</a></h3>
<ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java 语言却提供了多线程支持）；</li>
<li>支持网络编程并且很方便（Java 语言诞生本身就是为简化网络编程设计的，因此Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存。</li>
</ol>
<h3 id="_2">面向对象和面向过程的区别？<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>面向对象和面向过程是一种软件开发思想。</p>
<p>面向过程就是分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用就可以了。</p>
<p>面向对象是把构成问题事务分解成各个对象，分别设计这些对象，然后将他们组装成有完整功能的系统。面向过程只用函数实现，面向对象是用类实现各个功能模块。</p>
<p>以五子棋为例，面向过程的设计思路就是首先分析问题的步骤：</p>
<p>1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。 把上面每个步骤用分别的函数来实现，问题就解决了。</p>
<p>而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为：</p>
<ol>
<li>
<p>黑白双方</p>
</li>
<li>
<p>棋盘系统，负责绘制画面</p>
</li>
<li>
<p>规则系统，负责判定诸如犯规、输赢等。</p>
</li>
</ol>
<p>黑白双方负责接受用户的输入，并告知棋盘系统棋子布局发生变化，棋盘系统接收到了棋子的变化的信息就负责在屏幕上面显示出这种变化，同时利用规则系统来对棋局进行判定。</p>
<h3 id="_3">面向对象和面向过程的区别<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<ul>
<li>** <strong>**面向过程</strong></li>
</ul>
<p><strong>优点：</strong>性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。</p>
<p><strong>缺点：</strong>没有面向对象易维护、易复用、易扩展。</p>
<ul>
<li><strong>面向对象</strong></li>
</ul>
<p><strong>优点：</strong>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p>
<p><strong>缺点：</strong>性能比面向过程低。</p>
<h3 id="java_4">Java 面向对象编程三大特性: 封装 继承 多态<a class="headerlink" href="#java_4" title="Permanent link">&para;</a></h3>
<ul>
<li>** <strong>**封装</strong></li>
</ul>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<ul>
<li><strong>继承</strong></li>
</ul>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>
<p>子类拥有父类非private 的属性和方法。</p>
</li>
<li>
<p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li>
<p>子类可以用自己的方式实现父类的方法。（以后介绍）。</p>
</li>
<li>
<p><strong>多态</strong></p>
</li>
</ol>
<p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<h3 id="_4">面向对象的特征有哪些方面?<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>面向对象的特征主要有以下4个方面：</p>
<p>抽象、封装、继承、多态</p>
<ul>
<li>抽象</li>
</ul>
<p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>
<ul>
<li>继承</li>
</ul>
<p>继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段（如果不能理解请阅读阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分）。</p>
<ul>
<li>封装</li>
</ul>
<p>通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）。</p>
<ul>
<li>多态性</li>
</ul>
<p><u>多态性是指允许不同子类型的对象对同一消息作出不同的响应。</u>简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</p>
<h3 id="_5">面向对象有哪些特性？<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>面向对象四大特性：封装，继承，多态，抽象</p>
<p>1、封装就是将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。 良好的封装能够减少耦合。</p>
<p>2、继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能扩展新的能力，大大增加程序的重用性和易维护性。在Java中是单继承的，也就是说一个子类只有一个父类。</p>
<p>3、多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。</p>
<p>静态多态性：通过重载实现，相同的方法有不同的參数列表，可以根据参数的不同，做出不同的处理。</p>
<p>动态多态性：在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。</p>
<p>4、抽象。把客观事物用代码抽象出来。</p>
<h3 id="_6">面向对象的特征有哪些方面<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<ul>
<li>抽象：</li>
</ul>
<p>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</p>
<ul>
<li>继承：</li>
</ul>
<p>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类(子类)，而原始类称为新类的基类(父类)。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</p>
<ul>
<li>封装：</li>
</ul>
<p>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</p>
<ul>
<li>多态性：</li>
</ul>
<p>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p>
<h3 id="_7">面向对象的特征<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>1） 继承：通过子类可以实现继承，子类继承父类的所有状态和行为，同时添加自身的状态和行为。</p>
<p>2） 封装：将代码及处理数据绑定在一起的一种编程机制，该机制保证程序和数据不受外部干扰。</p>
<p>3） 多态：包括重载和重写。重载为编译时多态，重写是运行时多态。<br />
重载必须是同类中名称相同参数不同（包括个数不同和类型不同），但返回类型不同不构成重载；<br />
重写发生于子类对父类的覆盖，子类继承父类方法名相同、参数列表相同、返回类型相同才构成重写。</p>
<h3 id="_8">什么是多态<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h3>
<p><strong>1.</strong><strong> </strong><strong>面向对象的三大特性</strong>：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</p>
<p><strong>2.</strong><strong> </strong><strong>多态的定义</strong>：<u>指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</u></p>
<p><strong>3.</strong><strong> </strong><strong>实现多态的技术称为</strong>：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。</p>
<p><strong>4.</strong><strong> </strong><strong>多态的作用</strong>：<u>消除类型之间的耦合关系</u>。</p>
<p><strong>5.</strong><strong> </strong><strong>现实中，关于多态的例子不胜枚举</strong>。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。</p>
<p>下面是多态存在的三个必要条件，要求大家做梦时都能背出来！</p>
<p>多态存在的三个必要条件<br />
<u>一、要有继承；</u><br />
<u>二、要有重写；</u><br />
<u>三、父类引用指向子类对象</u>。</p>
<p>Java中多态的实现方式：<u>接口实现，继承父类进行方法重写，同一个类中进行方法重载。</u></p>
<h3 id="_9">继承和多态的区别<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p>继承是指在子类中使用超类的结构和行为。多态性是指改变子类中超类的行为。</p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_23994787/article/details/75452028">多态与继承的概念及区别_心歌技术的博客-CSDN博客_继承和多态的区别</a>
</p>
</blockquote>
<h3 id="java_5">Java 多态（乐视）<a class="headerlink" href="#java_5" title="Permanent link">&para;</a></h3>
<blockquote>
<p><a href="http://blog.csdn.net/Jian_Yun_Rui/article/details/52937791">Java多态性理解，好处及精典实例_JIAN_BOY_RISE的博客-CSDN博客_多态的好处</a>
</p>
</blockquote>
<h3 id="java_6">Java 中实现多态的机制是什么？<a class="headerlink" href="#java_6" title="Permanent link">&para;</a></h3>
<p>多态是指程序中<u>定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时不确定，在运行期间才确定，一个引用变量到底会指向哪个类的实例。</u>这样就可以不用修改源程序，就可以让引用变量绑定到各种不同的类实现上。</p>
<p>Java 实现多态有三个必要条件： </p>
<p>继承、重定、向上转型，在多态中需要将子类的引用赋值给父类对象，只有这样该引用才能够具备调用父类方法和子类的方法。 </p>
<h3 id="java_7">谈谈对 java 多态的理解<a class="headerlink" href="#java_7" title="Permanent link">&para;</a></h3>
<p>同一个消息可以根据发送对象的不同而采用多种不同的行为方式，在执行期间判断所引用的对象的实际类型，根据其实际的类型调用其相应的方法。 </p>
<p>作用：消除类型之间的耦合关系。实现多态的必要条件：继承、重写（因为必须调用父类中存在的方法）、父类引用指向子类对象。</p>
<h3 id="java_8">Java的四个基本特性（抽象、封装、继承，多态），对多态的理解(多态的实现方式)以及在项目中那些地方用到多态<a class="headerlink" href="#java_8" title="Permanent link">&para;</a></h3>
<ul>
<li>Java的四个基本特性<ul>
<li>抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</li>
<li>继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手 段。</li>
<li>封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</li>
<li>多态性是指允许不同子类型的对象对同一消息作出不同的响应。</li>
</ul>
</li>
<li>多态的理解(多态的实现方式)<ul>
<li>方法重载（overload）实现的是编译时的多态性（也称为前绑定）。</li>
<li>方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西。</li>
<li>要实现多态需要做两件事：<br />
1) 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；<br />
2) 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。</li>
</ul>
</li>
</ul>
<p>• 项目中对多态的应用</p>
<p>举一个简单的例子，在物流信息管理系统中，有两种用户：订购客户和卖房客户，两个客户都可以登录系统，他们有相同的方法Login，但登陆之后他们会进入到不同的页面，也就是在登录的时候会有不同的操作，两种客户都继承父类的Login方法，但对于不同的对象，拥有不同的操作。</p>
<h3 id="_10">面向对象和面向过程的区别？用面向过程可以实现面向对象吗？那是不是不能面向对象？<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>面向对象和面向过程的区别</strong></li>
</ul>
<p>面向过程就像是一个细心的管家，事无具细的都要考虑到。而面向对象就像是个家用电器，你只需要知道他的功能，不需要知道它的工作原理。</p>
<p>面向过程”是一种是事件为中心的编程思想。就是分析出解决问题所需的步骤，然后用函数把这些步骤实现，并按顺序调用。面向对象是以“对象”为中心的编程思想。</p>
<p>简单的举个例子：汽车发动、汽车到站</p>
<p>这对于“面向过程”来说，是两个事件，汽车启动是一个事件，汽车到站是另一个事件，面向过程编程的过程中我们关心的是事件，而不是汽车本身。针对上述两个事件，形成两个函数，之后依次调用。</p>
<p>然而这对于面向对象来说，我们关心的是汽车这类对象，两个事件只是这类对象所具有的行为。而且对于这两个行为的顺序没有强制要求。</p>
<ul>
<li><strong>用面向过程可以实现面向对象吗</strong></li>
</ul>
<p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。</p>
<p>面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。</p>
<p>只要明白两者的区别，将面向过程转变为面向对象是可行的。它是一种编程思想，只要贯彻这种思想来编程，是可以实现类似的效果的。</p>
<blockquote>
<p><a href="https://zhidao.baidu.com/question/1370231065055979819.html">用面向过程可以实现面向对象吗？_百度知道</a>
</p>
</blockquote>
<h3 id="oop">OOP是什么<a class="headerlink" href="#oop" title="Permanent link">&para;</a></h3>
<p>面向对象编程，一种编程思想，万物皆对象</p>
<h3 id="javaoop">Java(OOP)面向对象的三个特征与含义<a class="headerlink" href="#javaoop" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>封装：</strong>可见性封装，set/get读写，将类的某些特征隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。</li>
<li><strong>继承：</strong>子类继承父类，可以得到父类的全部属性和方法（除了父类中的构造方法），java中的多继承可以通过接口来实现。</li>
<li><strong>多态：</strong>一种是<strong>编译时多态</strong>，另外一种是<strong>运行时多态</strong>。编译时多态是通过<strong>方法的重载</strong>来实现的，运行时多态是通过<strong>方法的重写</strong>来实现的。</li>
</ul>
<h3 id="aop">AOP是什么<a class="headerlink" href="#aop" title="Permanent link">&para;</a></h3>
<p>面向切面编程，不影响功能的情况下添加内容扩展，比如添加log，权限等。通过<strong>Aspect切面</strong>，把<strong>业务中共用的逻辑或者责任封装起来</strong>，减少重复代码，降低模块之间的耦合度。</p>
<p>相关概念</p>
<p>1、横切关注点</p>
<p>对哪些<strong>方法</strong>进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
<p>2、切面（aspect）</p>
<p>类是对物体特征的抽象，切面就是<strong>对</strong><strong>横切关注点的抽象</strong></p>
<p>3、连接点（joinpoint）</p>
<p>被拦截到的点，可以是<strong>字段</strong>或者<strong>构造器。</strong></p>
<p>因为Spring只支持<strong>方法类型</strong>的连接点，所以在Spring中连接点指的就是被拦截到的方法。</p>
<p>4、切入点（pointcut）</p>
<p>对<strong>连接点进行拦截</strong>的定义</p>
<p>5、通知（advice）</p>
<p>所谓通知指的就是指<strong>拦截到连接点之后要执行的代码</strong>，通知分为<strong>前置、后置、异常、最终、环绕</strong><strong>通知</strong>五类</p>
<p>6、目标对象</p>
<p>被代理的目标对象</p>
<p>7、织入（weave）</p>
<p>将<strong>切面应用到目标对象</strong>并<strong>导致代理</strong><strong>对象创建</strong>的过程</p>
<p>8、引入（introduction）</p>
<p>在不修改代码的前提下，引入可以在<strong>运行期</strong>为类动态地添加一些<strong>方法</strong>或<strong>字段</strong></p>
<h3 id="aopoop">AOP与OOP的区别<a class="headerlink" href="#aopoop" title="Permanent link">&para;</a></h3>
<p><strong>AOP: </strong>(Aspect Oriented Programming) <strong>面向切面</strong>编程。是目前软件开发中的一个热点，也是Spring框架中容。利用AOP可以对业务逻辑的<strong>各个部分进行隔离</strong>，从而使得业务逻辑各部分之间的<strong>耦合度降低</strong>，提高程序的<strong>可重用性</strong>，同时提高了<strong>开发的效率</strong>。</p>
<p>主要的功能是：<strong>日志记录，性能统计，安全控制，事务处理，异常处理</strong>等。</p>
<p>AOP与OOP在字面上虽然非常类似，却是面向不同领域的两种设计思想。OOP（<strong>面向对象</strong>编程）针对业务处理过程的实体及其<strong>属性和行为</strong>进行抽象封装，以获得更加清晰高效的逻辑单元划分。 而AOP则是针<strong>对业务处理过程中的切面进行提取</strong>，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。</p>
<h3 id="jdkjrejvm">JDK、JRE、JVM<a class="headerlink" href="#jdkjrejvm" title="Permanent link">&para;</a></h3>
<p>(1) JVM</p>
<p>JVM是Java虚拟机，保证Java语言跨平台。</p>
<p>问题：java语言是跨平台的吗?JVM是跨平台的吗?</p>
<p>java语言跨平台，JVM不跨平台</p>
<p>(2) JRE</p>
<p>java程序的运行环境，包括JVM和核心类库。</p>
<p>(3) JDK</p>
<p>java开发环境，包括JRE和开发工具(javac,java)。</p>
<p>(4) 一个Java程序的开发流程</p>
<p>A:编写Java源程序</p>
<p>B:通过javac命令编译java程序，生成字节码文件</p>
<p>C:通过java命令运行字节码文件</p>
<h3 id="jdk">JDK源码，了解哪些常用库<a class="headerlink" href="#jdk" title="Permanent link">&para;</a></h3>
<p>常用的 Java 核心包 (Java Core Package)</p>
<ol>
<li>java.lang      Java 编程语言的基本类库</li>
<li>java.applet     创建 applet 需要的所有类</li>
<li>java.awt       创建用户界面以及绘制和管理图形、图像的类</li>
<li>java.io        通过数据流、对象序列以及文件系统实现的系统输入、输出</li>
<li>java.net       用于实现网络通讯应用的所有类</li>
<li>java.util       集合类、时间处理模式、日期时间工具等各类常用工具包</li>
</ol>
<p>其它还有</p>
<ol>
<li>java.sql        访问和处理来自于 Java 标准数据源数据的类</li>
<li>java.test       以一种独立于自然语言的方式处理文本、日期、数字和消息的类和接口</li>
<li>java.security    设计网络安全方案需要的一些类</li>
<li>java.beans     开发 Java Beans 需要的所有类</li>
<li>java.math      简明的整数算术以及十进制算术的基本函数</li>
<li>java.rmi       与远程方法调用相关的所有类</li>
</ol>
<p>常用的 Java 扩展包 (Java Extension Package)</p>
<ol>
<li>javax.accessibility  定义了用户界面组件之间相互访问的一种机制</li>
<li>javax.naming.*     为命名服务提供了一系列类和接口</li>
<li>javax.swing.*       提供了一系列轻量级的用户界面组件，是目前 Java 用户界面常用的包</li>
</ol>
<blockquote>
<p><a href="https://blog.csdn.net/basycia/article/details/50769838">Java需要掌握的常用类库_雪飞静的博客-CSDN博客</a>
</p>
</blockquote>
<h3 id="jvm-jdk-jre">关于 JVM JDK 和 JRE 最详细通俗的解答<a class="headerlink" href="#jvm-jdk-jre" title="Permanent link">&para;</a></h3>
<ul>
<li><strong><em>*</em>*JVM</strong></li>
</ul>
<p>Java 虚拟机（JVM）是运行Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>
<p>在Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为.class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同的计算机上运行。</p>
<p><strong>Java 程序从源代码到运行一般有下面3 步：</strong></p>
<p><img alt="1664559843306-3fd5131c-6f82-408d-877a-62c0712609a6.png" src="img/jlawb-ju2rf3fWw4/1664559843306-3fd5131c-6f82-408d-877a-62c0712609a6-775916.png" /></p>
<p>我们需要格外注意的是.class-&gt;机器码这一步。在这一步jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代码，所以后面引进了JIT 编译器，JIT 属于运行时编译。当JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于Java 解释器的。这也解释了我们为什么经常会说Java 是编译与解释共存的语言。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT 预热等各方面的开销。JDK 支持分层编译和AOT 协作使用。但是， AOT 编译器的编译质量是肯定比不上JIT 编译器的。
</p>
</blockquote>
<p>总结：Java 虚拟机（JVM）是运行Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM 实现是Java 语言“一次编译，随处可以运行”的关键所在。</p>
<ul>
<li><strong>JDK 和JRE</strong></li>
</ul>
<p>JDK 是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE 所拥有的一切，还有编译器（javac）和工具（如javadoc 和jdb）。它能够创建和编译程序。</p>
<p>JRE 是Java 运行时环境。它是运行已编译Java 程序所需的所有内容的集合，包括Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下Java 程序的话，那么你只需要安装JRE 就可以了。如果你需要进行一些Java 编程方面的工作，那么你就需要安装JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java 开发，仍然需要安装JDK。例如，如果要使用JSP 部署Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java 程序。那你为什么需要JDK 呢？因为应用程序服务器会将JSP 转换为Java servlet，并且需要使用JDK 来编译servlet。</p>
<h3 id="oracle-jdk-openjdk">Oracle JDK 和 OpenJDK 的对比<a class="headerlink" href="#oracle-jdk-openjdk" title="Permanent link">&para;</a></h3>
<p>** **可能在看这个问题之前很多人和我一样并没有接触和使用过OpenJDK 。那么Oracle 和OpenJDK 之间是否存在重大差异？下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题。</p>
<p>对于Java 7，没什么关键的地方。OpenJDK 项目主要基于Sun 捐赠的HotSpot源代码。此外，OpenJDK 被选为Java 7 的参考实现，由Oracle 工程师维护。</p>
<p>关于JVM，JDK，JRE 和OpenJDK 之间的区别，Oracle 博客帖子在2012 年有一个更详细的答案：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建Oracle JDK 的代码之间有什么区别？</p>
<p>非常接近- 我们的Oracle JDK 版本构建过程基于OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括Oracle 的Java 插件和Java WebStart的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源Oracle JDK 的所有部分，除了我们考虑商业功能的部分。
</p>
</blockquote>
<p>总结：</p>
<ol>
<li>
<p>Oracle JDK 版本将每三年发布一次，而OpenJDK 版本每三个月发布一次；</p>
</li>
<li>
<p>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK 是OpenJDK 的一个实现，并不是完全开源的；</p>
</li>
<li>
<p>Oracle JDK 比OpenJDK 更稳定。OpenJDK 和Oracle JDK 的代码几乎相同，但Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK 就可以解决问题；</p>
</li>
<li>
<p>顶级公司正在使用Oracle JDK，例如Android Studio，Minecraft 和IntelliJ IDEA 开发工具，其中Open JDK 不太受欢迎；</p>
</li>
<li>
<p>在响应性和JVM 性能方面，Oracle JDK 与OpenJDK 相比提供了更好的性能；</p>
</li>
<li>
<p>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</p>
</li>
<li>
<p>Oracle JDK 根据二进制代码许可协议获得许可，而OpenJDK 根据GPL v2 许可获得许可。</p>
</li>
</ol>
<h3 id="jdkjre">JDK和JRE的区别？<a class="headerlink" href="#jdkjre" title="Permanent link">&para;</a></h3>
<p>JDK和JRE是Java开发和运行工具，其中JDK包含了JRE，而JRE是可以独立安装的。</p>
<p><strong>JDK</strong>：Java Development Kit，JAVA语言的软件工具开发包，是整个JAVA开发的核心，它包含了JAVA的运行（JVM+JAVA类库）环境和JAVA工具。</p>
<p><strong>JRE</strong>：Java Runtime Environment，Java运行环境，包含JVM标准实现及Java核心类库。JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器）。</p>
<p>JRE是运行基于Java语言编写的程序所不可缺少的运行环境。也是通过它，Java的开发者才得以将自己开发的程序发布到用户手中，让用户使用。</p>
<h3 id="java_9">什么是Java 程序的主类应用程序？和小程序的主类有何不同？<a class="headerlink" href="#java_9" title="Permanent link">&para;</a></h3>
<p>** **一个程序中可以有多个类，但只能有一个类是主类。在Java 应用程序中，这个主类是指包含main()方法的类。</p>
<p>而在Java 小程序中，这个主类是一个继承自系统类<code>JApplet</code> 或<code>Applet</code> 的子类。</p>
<p>应用程序的主类不一定要求是public类，但小程序的主类要求必须是public 类。主类是Java 程序执行的入口点。</p>
<h3 id="java_10">Java 应用程序与小程序之间有那些差别<a class="headerlink" href="#java_10" title="Permanent link">&para;</a></h3>
<p>** **简单说应用程序是从主线程启动(也就是main() 方法)。applet 小程序没有main 方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash 的小游戏类似。</p>
<h3 id="_11">引用数据类型<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
<h3 id="_12">类、对象的概念<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h3>
<p>1、类、对象的概念：</p>
<p>1） 类：具有共同属性和行为的对象的抽象。类是创建对象的模板。</p>
<p>2） 对象：现实世界中的实体。在计算机中，是指可标识的存储区域。</p>
<p>3） 类是对象的抽象、对象是类的实例。</p>
<p>2、抽象：是从特定的实例中抽取共同性质形成一般化概念的过程。</p>
<h3 id="java_11">Java创建对象有几种方式？<a class="headerlink" href="#java_11" title="Permanent link">&para;</a></h3>
<p>Java创建对象有以下几种方式：</p>
<p>用new语句创建对象。</p>
<p>使用反射，使用Class.newInstance()创建对象。调用对象的clone()方法。</p>
<p>运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。</p>
<h3 id="java_12">Java支持多继承吗？<a class="headerlink" href="#java_12" title="Permanent link">&para;</a></h3>
<p>java中，<strong>类不支持</strong>多继承。<strong>接口才支持</strong>多继承。接口的作用是拓展对象功能。当一个子接口继承了多个父接口时，说明子接口拓展了多个功能。当一个类实现该接口时，就拓展了多个的功能。</p>
<p>Java不支持多继承的原因：</p>
<p>出于安全性的考虑，如果子类继承的多个父类里面有相同的方法或者属性，子类将不知道具体要继承哪个。</p>
<p>Java提供了接口和内部类以达到实现多继承功能，弥补单继承的缺陷。</p>
<h3 id="_13">类可以继承多个类么？<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h3>
<p>类只能继承一个父类。</p>
<h3 id="_14">接口可以继承多个接口么？<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h3>
<p>接口可以继承多个父接口。</p>
<h3 id="_15">类可以实现多个接口么？<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h3>
<p>类可以实现多个接口。</p>
<h3 id="constructor-override">构造器 Constructor 是否可被 override<a class="headerlink" href="#constructor-override" title="Permanent link">&para;</a></h3>
<p>在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor 也就不能被override（重写），但是可以overload（重载），所以你可以看到一个类中有多个构造函数的情况。</p>
<h3 id="equals">equals与==的区别<a class="headerlink" href="#equals" title="Permanent link">&para;</a></h3>
<ul>
<li>== 比较的是2个对象的地址，而equals比较的是2个对象的内容。</li>
<li>== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否指相同一个对象。比较的是真正意义上的指针操作。</li>
<li>equals用来比较两个对象的内容是否相等。由于所有的类都继承自java.lang.Object类，所以，适用于所有对象。如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。</li>
</ul>
<h3 id="equals_1">==和equals的区别<a class="headerlink" href="#equals_1" title="Permanent link">&para;</a></h3>
<p>==比的是java的基本类型，值是否相等，比对象的变量类型，引用是否相同；</p>
<p>equals比的是内容是否相等。</p>
<h3 id="equals_2">== 与 equals(重要)<a class="headerlink" href="#equals_2" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>== </strong>: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</li>
<li><strong>equals() </strong>: 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：<ul>
<li>情况1：类没有覆盖equals() 方法。则通过equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况2：类覆盖了equals() 方法。一般，我们都覆盖equals() 方法来两个对象的内容相等；若它们的内容相等，则返回true (即，认为这两个对象相等)。</li>
</ul>
</li>
</ul>
<p><strong>举个例子：</strong></p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">test1</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="s">&quot;ab&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// a 为一个引用</span>
<span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">String</span><span class="p">(</span><span class="s">&quot;ab&quot;</span><span class="p">);</span><span class="w"> </span><span class="c1">// b 为另一个引用,对象的内容一样</span>
<span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">aa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;ab&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 放在常量池中 String bb = &quot;ab&quot;; // 从常量池中查找 if (aa == bb) // true</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;aa==bb&quot;</span><span class="p">);</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="c1">// false，非同一对象</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;a==b&quot;</span><span class="p">);</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="c1">// true</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;aEQb&quot;</span><span class="p">);</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">42</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">42.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// true</span>
<span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;true&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>说明：</strong></p>
<ul>
<li>String 中的equals 方法是被重写过的，因为object 的equals 方法是比较的对象的内存地址，而String 的equals 方法比较的是对象的值。</li>
<li>当创建String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String 对象。</li>
</ul>
<h3 id="hashcode-equals">Hashcode（）和 equals（）和 == 区别?<a class="headerlink" href="#hashcode-equals" title="Permanent link">&para;</a></h3>
<p>(1) hashcode()方法跟 equals()在 java 中都是判断两个对象是否相等 </p>
<p>(2) 两个对象相同，则 hashcode 至一定要相同，即对象相同 ----&gt; 成员变量相同 ----&gt; hashcode 值一定相同 </p>
<p>(3) 两个对象的 hashcode 值相同，对象不一定相等。总结：equals 相等则 hashcode 一定相等，hashcode 相等，equals 不一定相等。 </p>
<p>(4) ==比较的是两个引用在内存中指向的是不是<strong>同一对象（即同一内存空间）</strong></p>
<h3 id="java-equals-hashcode">java 中==和 equals 和 hashCode 的区别<a class="headerlink" href="#java-equals-hashcode" title="Permanent link">&para;</a></h3>
<p>1）==若是基本数据类型比较，是比较值，若是引用类型，则比较的是他们在内存中的存放地址。对象是存放在堆中，栈中存放的对象的引用，所以==是对栈中的值进行比较，若返回 true 代表变量的内存地址相等； </p>
<p>2）equals 是 Object 类中的方法，Object 类的 equals 方法用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。若是类中覆盖了 equals 方法，就要根据具体代码来确定，一般覆盖后都是通过对象的内容是否相等来判断对象是否相等。 </p>
<p>3）hashCode()计算出对象实例的哈希码，在对象进行散列时作为 key 存入。之所以有hashCode 方法，因为在批量的对象比较中，hashCode 比较要比 equals 快。在添加新元素时，先调用这个元素的 hashCode 方法，一下子能定位到它应该旋转的物理位置，若该位置没有元素，可直接存储；若该位置有元素，就调用它的 equals 方法与新元素进行比较，若相同则不存，不相同，就放到该位置的链表末端。 </p>
<p>4）equals 与 hashCode 方法关系： </p>
<p>hashCode()是一个本地方法，实现是根据本地机器上关的。</p>
<p>equals()相等的对象，hashCode()也一定相等；</p>
<p>hashCode()不等，equals()一定也不等；</p>
<p>hashCode()相等，equals() 可能相等，也可能不等。 </p>
<p>所以在重写 equals(Object obj) 方法，有必要重写 hashCode() 方法，确保通过equals(Object obj)方法判断结果为 true 的两个对象具备相等的 hashCode()返回值。 </p>
<p>5）equals 与==的关系： </p>
<p><code>Integer b1 = 127;</code>在 java 编译时被编译成<code>Integer b1 = Integer.valueOf(127);</code>对于-128 到 127 之间的 Integer 值，用的是原生数据类型 int，会在内存里供重用，也就是这之间的Integer 值进行==比较时，只是进行 int 原生数据类型的数值进行比较。而超出-128〜127的范围，进行==比较时是进行地址及数值比较。 </p>
<h3 id="java-equals-equals-hashcode">Java 中==和 equals 的区别， equals 和 hashCode 的区别（乐视）<a class="headerlink" href="#java-equals-equals-hashcode" title="Permanent link">&para;</a></h3>
<blockquote>
<p><a href="http://blog.csdn.net/tiantiandjava/article/details/46988461">Java中==和equals的区别，equals和hashCode的区别_天天的博客-CSDN博客</a>
</p>
</blockquote>
<h3 id="equals_3">equals和==有什么区别？<a class="headerlink" href="#equals_3" title="Permanent link">&para;</a></h3>
<p>对于基本数据类型，==比较的是他们的值。基本数据类型没有equal方法；</p>
<p>对于复合数据类型，==比较的是它们的存放地址(是否是同一个对象)。equals() 默认比较地址值，重写的话按照重写逻辑去比较。</p>
<h3 id="a-equals-hashmap-equals">修改对象 A 的 equals 方法的签名，那么使用 HashMap 存放这个对象实例的时候，会调用哪个 equals 方法？<a class="headerlink" href="#a-equals-hashmap-equals" title="Permanent link">&para;</a></h3>
<p>会调用对象的 equals 方法，如果对象的 equals 方法没有被重写，equals 方法和==都是比较栈内局部变量表中指向堆内存地址值是否相等。 </p>
<h3 id="hashcode-equals_1">hashCode 与 equals（重要）<a class="headerlink" href="#hashcode-equals_1" title="Permanent link">&para;</a></h3>
<p>面试官可能会问你：“你重写过hashcode 和equals 么，为什么重写equals时必须重写hashCode 方法？”</p>
<ul>
<li><strong>hashCode（）介绍</strong></li>
</ul>
<p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK 的Object.java 中，这就意味着Java 中的任何类都包含有hashCode() 函数。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<ul>
<li><strong>为什么要有 hashCode</strong></li>
</ul>
<p><strong>我们以“HashSet 如何检查重复”为例子来说明为什么要有hashCode：</strong></p>
<p>当你把对象加入HashSet 时，HashSet 会先计算对象的hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode 值作比较，如果没有相符的hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同hashcode 值的对象，这时会调用equals（）方法来检查hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java 启蒙书《Head first java》第二版）。这样我们就大大减少了equals 的次数，相应就大大提高了执行速度。</p>
<ul>
<li>
<p><strong>hashCode（）与equals（）的相关规定</strong></p>
</li>
<li>
<p>如果两个对象相等，则hashcode 一定也是相同的</p>
</li>
<li>
<p>两个对象相等,对两个对象分别调用equals 方法都返回true</p>
</li>
<li>
<p>两个对象有相同的hashcode 值，它们也不一定是相等的</p>
</li>
<li>
<p><strong>因此，equals 方法被覆盖过，则hashCode 方法也必须被覆盖</strong></p>
</li>
<li>
<p>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p>
</li>
</ul>
<h3 id="object">Object有哪些公用方法<a class="headerlink" href="#object" title="Permanent link">&para;</a></h3>
<ol>
<li>clone()</li>
<li>hashCode()</li>
<li>equals()</li>
<li>notify()</li>
<li>notifyAll()</li>
<li>wait()</li>
<li>getClass()</li>
<li>toString</li>
<li>finalize()</li>
</ol>
<h3 id="object_1">Object常用方法有哪些？<a class="headerlink" href="#object_1" title="Permanent link">&para;</a></h3>
<p>Java面试经常会出现的一道题目，Object的常用方法。下面给大家整理一下。Object常用方法有：toString() 、equals() 、hashCode() 、clone() 等。</p>
<ul>
<li><strong>toString</strong></li>
</ul>
<p>默认输出对象地址。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Person</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;程序员大彬&quot;</span><span class="p">).</span><span class="na">toString</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//output</span>
<span class="w">    </span><span class="c1">//me.tyson.java.core.Person@4554617c</span>
<span class="p">}</span>
</code></pre></div>
<p>可以重写toString方法，按照重写逻辑输出对象值。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Person</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">toString</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;:&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;程序员大彬&quot;</span><span class="p">).</span><span class="na">toString</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//output</span>
<span class="w">    </span><span class="c1">//程序员大彬:18</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><strong>equals</strong></li>
</ul>
<p>默认比较两个引用变量是否指向同一个对象（内存地址）。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Person</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;程序员大彬&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"> </span>
<span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>

<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">p2</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//output</span>
<span class="w">    </span><span class="c1">//false</span>
<span class="p">}</span>
</code></pre></div>
<p>可以重写equals方法，按照age和name是否相等来判断：</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">;</span><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Person</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="n">Object</span><span class="w"> </span><span class="n">o</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">o</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">Person</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Person</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Person</span><span class="p">)</span><span class="w"> </span><span class="n">o</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="na">age</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="na">name</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;程序员大彬&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>

<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">p2</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//output</span>
<span class="w">    </span><span class="c1">//true</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><strong>hashCode</strong></li>
</ul>
<p>将与对象相关的信息映射成一个哈希值，默认的实现hashCode值是根据内存地址换算出来。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Cat</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Cat</span><span class="p">().</span><span class="na">hashCode</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//out</span>
<span class="w">    </span><span class="c1">//1349277854</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><strong>clone</strong></li>
</ul>
<p>Java赋值是复制对象引用，如果我们想要得到一个对象的副本，使用赋值操作是无法达到目的的。 Object对象有个clone()方法，实现了对</p>
<p>象中各个属性的复制，但它的可见范围是protected的。</p>
<div class="highlight"><pre><span></span><code><span class="kd">protected</span><span class="w"> </span><span class="kd">native</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">clone</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">CloneNotSupportedException</span><span class="p">;</span>
</code></pre></div>
<p>所以实体类使用克隆的前提是：</p>
<p>实现Cloneable接口，这是一个标记接口，自身没有方法，这应该是一种约定。调用clone方法时，会判断有没有实现Cloneable接口，没有实现Cloneable的话会抛异常CloneNotSupportedException。</p>
<p>覆盖clone()方法，可见性提升为public。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Cat</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Cloneable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">clone</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">CloneNotSupportedException</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kd">super</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">CloneNotSupportedException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Cat</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Cat</span><span class="p">();</span>
<span class="w">        </span><span class="n">c</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;程序员大彬&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">Cat</span><span class="w"> </span><span class="n">cloneCat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Cat</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;大彬&quot;</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">cloneCat</span><span class="p">.</span><span class="na">name</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//output</span>
<span class="w">    </span><span class="c1">//程序员大彬</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><strong>getClass</strong></li>
</ul>
<p>返回此 Object 的运行时类，常用于java反射机制。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Person</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">                               </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="s">&quot;程序员大彬&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">Class</span><span class="w"> </span><span class="n">clz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="na">getClass</span><span class="p">();</span><span class="w"> </span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">clz</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//获取类名 System.out.println(clz.getName());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     *class com.tyson.basic.Person</span>
<span class="cm">     *com.tyson.basic.Person</span>
<span class="cm">     */</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><strong>wait</strong></li>
</ul>
<p>当前线程调用对象的wait()方法之后，当前线程会释放对象锁，进入等待状态。等待其他线程调用此对象的notify()/notifyAll()唤醒或者等待超时时间wait(long timeout)自动唤醒。线程需要获取obj对象锁之后才能调用 obj.wait()。</p>
<ul>
<li><strong>notify</strong></li>
</ul>
<p>obj.notify()唤醒在此对象上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象上等待的所有线程。</p>
<h3 id="hashcode">hashcode的作用<a class="headerlink" href="#hashcode" title="Permanent link">&para;</a></h3>
<blockquote>
<p>利用哈希算法，配合基于散列的集合一起正常运行，Java中的<code>hashCode()</code>方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。
</p>
</blockquote>
<p>降低equals的调用，实现存放的值不会重复。</p>
<p><strong>Note：重写equals必须重写hashCode方法，equals相等，hashcode也必须相等。</strong></p>
<p>一般对于存放到Set集合或者Map中键值对的元素，需要按需要重写<code>hashCode()</code>与<code>equals()</code>方法，以保证唯一性！</p>
<p>例如：HashSet存放多个对象，重写<code>equals()</code>和<code>hashCode()</code>方法。</p>
<ul>
<li>两个对象相等，其hashcode一定相同;</li>
<li>两个对象不相等，其hashcode有可能相同;</li>
<li>hashcode相同的两个对象，不一定相等;</li>
<li>hashcode不相同的两个对象，一定不相等。</li>
</ul>
<h3 id="object_2">Object类中有哪些方法<a class="headerlink" href="#object_2" title="Permanent link">&para;</a></h3>
<p>（1）clone方法</p>
<p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p>
<p>（2）getClass方法</p>
<p>final方法，获得运行时类型。</p>
<p>（3）toString方法</p>
<p>该方法用得比较多，一般子类都有覆盖。</p>
<p>（4）finalize方法</p>
<p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p>
<p>（5）equals方法</p>
<p>该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p>
<p>（6）hashCode方法</p>
<p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p>
<p>一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p>
<p>（7）wait方法</p>
<p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p>
<p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>
<p>（1）其他线程调用了该对象的notify方法。</p>
<p>（2）其他线程调用了该对象的notifyAll方法。</p>
<p>（3）其他线程调用了interrupt中断该线程。</p>
<p>（4）时间间隔到了。</p>
<p>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p>
<p>（8）notify方法</p>
<p>该方法唤醒在该对象上等待的某个线程。</p>
<p>（9）notifyAll方法</p>
<p>该方法唤醒在该对象上等待的所有线程。</p>
<blockquote>
<p><a href="https://www.php.cn/faq/416709.html">object类有哪些方法-常见问题-PHP中文网</a>
</p>
</blockquote>
<h3 id="hashcode_1">如何理解hashcode的作用<a class="headerlink" href="#hashcode_1" title="Permanent link">&para;</a></h3>
<p>从Object角度看，JVM每new一个Object，它都会将这个Object丢到一个Hash表中去，这样的话，下次做Object的比较或者取这个对象的时候（读取过程），它会根据对象的HashCode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。若HashCode相同再去调用equal()方法。</p>
<h3 id="hashcode_2">为什么重写hashCode()方法？<a class="headerlink" href="#hashcode_2" title="Permanent link">&para;</a></h3>
<p>一般的地方不需要重写<code>hashCode()</code>，只有当类需要放在Hashtable、HashMap、HashSet等等hash结构的集合时才会重写<code>hashCode()</code>。</p>
<p>那么为什么要重写<code>hashCode()</code>呢？</p>
<p>（1）HashMap进行put方法时，首先对key对象进行hash操作，其中就包含了<code>hashCode()</code>方法 的调用。通过<code>hashCode()</code>方法得到key的hash值，然后<strong>对hash值进行取模运算</strong>得到了<strong>在HashMap存储中的下标索引值</strong>。（详情可以自己查看源码）</p>
<p>（2）如果不重写<code>hashCode()</code>方法，即使相同内容的对象object1和object2，因为使用其<strong>引用地址作为输入</strong>计算得到的hash值也不一样，从而在HashMap中的索引值也不一样。</p>
<p>（3）在进行put操作时，由于索引不同，两个内容相同的对象被put进入不同的桶锁对应的链表中。</p>
<p>这样，HashMap中就存在了两个内容相同的对象，违背了HashMap的不含重复元素的特性。</p>
<p>因此，为了保证相同内容的对象，应该被put进入同一个桶所对应的链表，需要重写<code>hashCode()</code>方法。</p>
<p>重写hashcode方法后，计算hash值使用的对象的内容进行hash运算。可以保证两个内容相同的对象 ，计算得到的hash值相同，从而进一步计算得到的下标索引值相同，可以保证了两个内容相同的对象可以put进入同一个桶中。</p>
<blockquote>
<p><a href="https://blog.csdn.net/zz18435842675/article/details/126366711">为什么需要重写hashcode和equals方法_Zz罗伯特的博客-CSDN博客_为啥要重写hashcode和equals方法</a>
</p>
</blockquote>
<h3 id="equals_4">为什么重写equals()方法？<a class="headerlink" href="#equals_4" title="Permanent link">&para;</a></h3>
<p>（1）当我们重写了hashcode()方法之后，保证了两个内容相同的对象可以放到同一个桶中。<br />
（2）但是，当进行put方法的时候，找到指定下标索引后，还需要进行比较操作，如果该对象已经存在于链表中，则用新的value值将其覆盖；如果不存在，则插入到链表中；<br />
（3）而比较两个对象是否相同，使用的是equals（）方法。<br />
（4）假设我们没有重写equals方法，在put第二个内容相同的对象时，由于Object类的原生equals方法默认比较的是两个对象的引用地址，因此两个内容相同的对象，其equals方法返回值为false，则会认为插入的第二个对象在链表中不存在，而将第二个对象插入到链表，不会覆盖第一个对象；<br />
<strong>这样，还是违背了hashmap的不含重复元素的特性。<br />
</strong><strong>因此，为了保证相同内容的对象，应该在hashmap中只存在一个，需要重写equals方法。</strong><br />
（5）重写equals方法使其比较两个对象的内容是否相同，此时再次进行put操作，由于object2和object1的内容相同，equals方法返回true，则会使用object2对象覆盖掉object1，保证了hashmap中只包含了一个内容相同的对象；<br />
保证了hashmap不包含重复元素的这一特性。</p>
<blockquote>
<p><a href="https://blog.csdn.net/zz18435842675/article/details/126366711">为什么需要重写hashcode和equals方法_Zz罗伯特的博客-CSDN博客_为啥要重写hashcode和equals方法</a>
</p>
</blockquote>
<h3 id="overrideoverload">Override和Overload的含义去区别<a class="headerlink" href="#overrideoverload" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>重写</strong>，是子类覆盖父类方法，重新定义。<br />
但是，返回类型、参数、参数类型、抛出异常都和父类一致，<u>被覆盖的方法不能private</u>，子类函数访问权限要大于等于父类的，子类无法覆盖父类的static方法或private方法。</li>
<li><strong>重载</strong>，是一个类中，方法名同名。<br />
但是具有不同程度参数类型，不同的参数个数，不同的参数顺序。</li>
</ul>
<h3 id="_16">重载和重写的区别<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>override（重写）</p>
</li>
<li>
<p>方法名、参数、返回值相同。</p>
</li>
<li>
<p>子类方法不能缩小父类方法的访问权限。</p>
</li>
<li>
<p>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</p>
</li>
<li>
<p>存在于父类和子类之间。</p>
</li>
<li>
<p>方法被定义为final不能被重写。</p>
</li>
<li>
<p>overload（重载）</p>
</li>
<li>
<p>参数类型、个数、顺序至少有一个不相同。</p>
</li>
<li>
<p>不能重载只有返回值不同的方法名。</p>
</li>
<li>
<p>存在于父类和子类、同类中。</p>
</li>
</ul>
<h3 id="overloadoverride">重载（Overload）和重写（Override）的区别，重载的方法能否根据返回类型进行区分?<a class="headerlink" href="#overloadoverride" title="Permanent link">&para;</a></h3>
<p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p>
<p>补充：华为的面试题中曾经问过这样一个问题：为什么不能根据返回类型来区分重载，说出你的答案吧！</p>
<p><img alt="1664380306025-02334655-29ea-4b5c-aa50-d4aff53160a3.png" src="img/jlawb-ju2rf3fWw4/1664380306025-02334655-29ea-4b5c-aa50-d4aff53160a3-227889.png" /></p>
<h3 id="_17">方法重载和重写的区别？<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h3>
<p><strong>同个类中的多个方法可以有相同的方法名称，但是有不同的参数列表，这就称为方法重载。</strong>参数列表又叫参数签名，包括参数的类型、参数的个数、参数的顺序，只要有一个不同就叫做参数列表不同。</p>
<p>重载是面向对象的一个基本特性。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">OverrideTest</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setPerson</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setPerson</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//set name</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">setPerson</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//set name and age</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>方法的重写描述的是父类和子类之间的。当父类的功能无法满足子类的需求，可以在子类对方法进行重</strong><strong>写。</strong>方法重写时， 方法名与形参列表必须一致。</p>
<p>如下代码，Person为父类，Student为子类，在Student中重写了dailyTask方法。</p>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dailyTask</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;work eat sleep&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dailyTask</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;study eat sleep&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="constructor">何时用覆盖，何时用重载？构造器Constructor是否可被覆盖/重载？<a class="headerlink" href="#constructor" title="Permanent link">&para;</a></h3>
<p>覆盖是用来实现多态；重载是用来使API更简洁易懂。Constructor不可以被覆盖，可以被重载。</p>
<h3 id="_18">重载和重写，如何确定调用哪个函数？<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h3>
<ul>
<li>重载：重载发生在同一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载。</li>
<li>重写：重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。根据不同的子类对象确定调用的那个方法。</li>
</ul>
<h3 id="_19">重载和重写的区别<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>重载：</strong>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。</li>
<li><strong>重写：</strong>发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private 则子类就不能重写该方法。</li>
</ul>
<h3 id="_20">子类能否重写父类的静态方法<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h3>
<p>不能，类对象，从属于对应的类。</p>
<h3 id="_21">父类的静态方法能否被子类重写？<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h3>
<p>父类的静态方法和属性不能被子类重写，但子类可以继承父类静态方法和属性，如父类和子类都有同名同参同返回值的静态方法 show()，声明的实例 Father father = new Son(); </p>
<p>(Son extends Father)，会调用 father 对象的静态方法。</p>
<h3 id="constructoroverride">构造器（constructor）是否可被重写（override）?<a class="headerlink" href="#constructoroverride" title="Permanent link">&para;</a></h3>
<p>构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h3 id="java_13">Java 访问修饰符权限的区别<a class="headerlink" href="#java_13" title="Permanent link">&para;</a></h3>
<ul>
<li><code>public</code> 所有类都可访问</li>
<li><code>protected</code> 只允许包内、子类访问。</li>
<li><code>default</code> 只允许包内访问</li>
<li><code>private</code> 只允许类内访问</li>
</ul>
<h3 id="java-id">Java 的序列化做什么用的？序列化id作用？<a class="headerlink" href="#java-id" title="Permanent link">&para;</a></h3>
<ul>
<li>序列化作用</li>
</ul>
<p>java对象序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。</p>
<p>序列化：将java对象转化为字节序列的过程。</p>
<p>反序列化：将字节序列转化为java对象的过程。</p>
<ul>
<li>序列化ID的作用</li>
</ul>
<p>其实，这个序列化ID起着关键的作用，它决定着是否能够成功反序列化！简单来说，java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</p>
<blockquote>
<p><a href="https://blog.csdn.net/liji_xc/article/details/47290695">java序列化和反序列化使用总结_ostracod_lvj的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/liji_xc/article/details/47302455">java 序列化ID的作用_ostracod_lvj的博客-CSDN博客</a>
</p>
</blockquote>
<h3 id="javajava">什么是java序列化，如何实现java序列化？<a class="headerlink" href="#javajava" title="Permanent link">&para;</a></h3>
<p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。</p>
<p>序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流。</p>
<h3 id="aa1a2aa-x-new-a1a1-x1-xa2-x2-x">假设A为一个基类，A1和A2都继承A。能不能写A x = new A1()？能不能写A1 x1 = x？能不能写A2 x2 = x？<a class="headerlink" href="#aa1a2aa-x-new-a1a1-x1-xa2-x2-x" title="Permanent link">&para;</a></h3>
<p>A x = new A1()可以；</p>
<p>A1 x1 = x需要加强制转换才能编译通过；</p>
<p>A2 x2 = x需要加强制转换才能编译通过，但是运行期会抛出ClassCastException</p>
<h3 id="extends-super">泛型中 extends 和 super 的区别<a class="headerlink" href="#extends-super" title="Permanent link">&para;</a></h3>
<? extends T>限定参数类型的**上界**，<u>参数类型必须是 T 或 T 的子类型</u>，但对于 List<? extends T>，不能通过 add()来加入元素，因为不知道<? extends T>是 T 的哪一种子类； 

<? super T>限定参数类型的**下界**，<u>参数类型必须是 T 或 T 的父类型</u>，不能能过 get()获取元素，因为不知道哪个超类。

### Cloneable 接口实现原理
Cloneable接口是Java开发中常用的一个接口， 它的作用是<u>使一个类的实例能够将自身拷贝到另一个新的实例中</u>。注意，这里所说的“拷贝”拷的是对象实例，而不是类的定义，进一步说，拷贝的是一个类的实例中各字段的值。

> 在开发过程中，拷贝实例是常见的一种操作，如果一个类中的字段较多，而我们又采用在客户端中逐字段复制的方法进行拷贝操作的话，将不可避免的造成客户端代码繁杂冗长，而且也无法对类中的私有成员进行复制，而如果让需要具备拷贝功能的类实现Cloneable接口，并重写clone()方法，就可以通过调用clone()方法的方式简洁地实现实例拷贝功能
>

深拷贝(深复制)和浅拷贝(浅复制)是两个比较通用的概念，尤其在C++语言中，若不弄懂，则会在delete的时候出问题，但是我们在这幸好用的是Java。虽然Java自动管理对象的回收，但对于深拷贝(深复制)和浅拷贝(浅复制)，我们还是要给予足够的重视，因为有时这两个概念往往会给我们带来不小的困惑。

浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象A1 中包含对B1 的引用， B1 中包含对C1 的引用。浅拷贝A1 得到A2 ， A2 中依然包含对B1 的引用， B1 中依然包含对C1 的引用。深拷贝则是对浅拷贝的递归，深拷贝A1 得到A2 ， A2 中包含对B2 （ B1 的copy ）的引用， B2 中包含对C2 （ C1 的copy ）的引用。

若不对clone()方法进行改写，则调用此方法得到的对象即为浅拷贝

### 在一个静态方法内调用一个非静态成员为什么是非法的
****由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

### 在Java 中定义一个不做事且没有参数的构造方法的作用
** **Java 程序在执行子类的构造方法之前，如果没有用super() 来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。

因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super() 来调用父类中特定的构造方法，则编译时将发生错误，因为Java 程序在父类中找不到没有参数的构造方法可供执行。

解决办法是<u>在父类里加上一个不做事且没有参数的构造方法</u>。

### import java 和 import javax 有什么区别 
刚开始的时候JavaAPI 所必需的包是java 开头的包，javax 当时只是扩展API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为Java API 的组成部分。但是，将扩展从javax 包移动到java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定javax 包将成为标准API 的一部分。

所以，实际上java 和javax 没有区别。这都是一个名字。

### 成员变量与局部变量的区别有那些 
1. 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及static 所修饰；但是，成员变量和局部变量都能被final 所修饰；

2. 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存；

3. 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失；

4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final 修饰的成员变量也必须显示地赋值）；而局部变量则不会自动赋值。

### 什么是方法的返回值？返回值在类的方法里的作用是什么？
方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。

返回值的作用：接收出结果，使得它可以用于其他的操作！

### 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？
主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

### 构造方法有哪些特性？ 
1. 名字与类名相同；

2. 没有返回值，但不能用void 声明构造函数；

3. 生成类的对象时自动执行，无需调用。

### 静态方法和实例方法有何不同
1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。

2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。

### 对象的相等与指向他们的引用相等，两者有什么不同？ 
对象的相等，比的是内存中存放的内容是否相等。

而引用相等，比较的是他们指向的内存地址是否相等。

### 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是? 
帮助子类做初始化工作。

### 为什么Java 中只有值传递
> [为什么Java中只有值传递？](https://github.com/Snailclimb/Java-Guide/blob/master/%25E9%259D%25A2%25E8%25AF%2595%25E5%25BF%2585%25E5%25A4%2587/%25E6%259C%2580%25E6%259C%2580%25E6%259C%2580%25E5%25B8%25B8%25E8%25A7%2581%25E7%259A%2584Java%25E9%259D%25A2%25E8%25AF%2595%25E9%25A2%2598%25E6%2580%25BB%25E7%25BB%2593/%25E7%25AC%25AC%25E4%25B8%2580%25E5%2591%25A8%25EF%25BC%25882018-8-7%25EF%25BC%2589.md)
>

### 获取用键盘输入常用的的两种方法
** **方法1：通过Scanner

<div class="highlight"><pre><span></span><code><span class="n">Scanner</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Scanner</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">);</span><span class="w"> </span>
<span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="na">nextLine</span><span class="p">();</span>
<span class="n">input</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
</code></pre></div>

 方法2：通过BufferedReader

<div class="highlight"><pre><span></span><code><span class="n">BufferedReader</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">BufferedReader</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">InputStreamReader</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">in</span><span class="p">));</span>
<span class="n">String</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="na">readLine</span><span class="p">();</span>
</code></pre></div>

### 因为别人知道源码怎么实现的，故意构造相同的hash的字符串进行攻击，怎么处理？那jdk7怎么办？
+ **构造相同hash的字符串攻击原理**
    - 当客户端提交一个请求并附带参数的时候，web应用服务器会把我们的参数转化成一个HashMap存储，这个 HashMap的逻辑结构如下：key1 --> value1;
    - 但是物理存储结构是不同的，key值会被转化成hashcode，这个hashcode又会被转成数组的下标：0 --> value1；
    - 不同的string就会产生相同hashcode而导致碰撞，碰撞后的物理存储结构可能如下：0 --> value1 --> value2;
+ **怎么处理构造相同hash的字符串进行攻击?**

1、限制post和get的参数个数，越少越好；

2、限制post数据包的大小；

3、WAF（Web Application Firewall，Web应用防火墙）

+ **Jdk7 如何处理hashcode字符串攻击**

HashMap会动态地使用一个专门的Treemap实现来替换掉它。

> [构造相同hash的字符串进行攻击，这种情况应该怎么处理？JDK7如何处理？_xk_一步一步来的博客-CSDN博客](https://blog.csdn.net/qq_32534441/article/details/89494470)
>

### Java序列化，如何实现序列化和反序列化
+ **Java序列化定义**

将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，序列化可以弥补不同操作系统之间的差异。

+ **Java序列化的作用**
    - Java远程方法调用（RMI）
    - 对JavaBeans进行序列化
+ **如何实现序列化和反序列化**
    - 实现Serializable接口
    - 该接口只是一个可序列化的标志，并没有包含实际的属性和方法。
    - 如果不在改方法中添加readObject()和writeObject()方法，则采取默认的序列化机制。如果添加了这两个方法之后还想利用Java默认的序列化机制，则在这两个方法中分别调用defaultReadObject()和 defaultWriteObject()两个方法。
    - 为了保证安全性，可以使用transient关键字进行修饰不必序列化的属性。因为在反序列化时，private修饰的属性也能发查看到。
    - 实现ExternalSerializable方法
    - 自己对要序列化的内容进行控制，控制那些属性能被序列化，那些不能被序列化。
+ **如何实现反序列化**
    -  实现Serializable接口的对象在反序列化时不需要调用对象所在类的构造方法，完全基于字节。
    -  实现externalSerializable接口的方法在反序列化时会调用构造方法。
+ **反序列化注意事项**
    - 被static修饰的属性不会被序列化
    - 对象的类名、属性都会被序列化，方法不会被序列化
    - 要保证序列化对象所在类的属性也是可以被序列化的
    - 当通过网络、文件进行序列化时，必须按照写入的顺序读取对象。
    - 反序列化时必须有序列化对象时的class文件
    - 最好显示的声明serializableID，因为在不同的JVM之间，默认生成serializableID 可能不同，会造成反序列化失败。

### Java 序列化中如果有些字段不想进行序列化怎么办？
对于不想进行序列化的变量，使用transient关键字修饰。

transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化。当对象被反序列化时，被transient 修饰的变量值不会被持久化和恢复。

transient 只能修饰变量，不能修饰类和方法。

### 常见的序列化协议有哪些
+ COM主要用于Windows平台，并没有真正实现跨平台，另外COM的序列化的原理利用了编译器中虚表，使得其学习成本巨大。
+ CORBA是早期比较好的实现了跨平台，跨语言的序列化协议。COBRA的主要问题是参与方过多带来的版本过多，版本之间兼容性较差，以及使用复杂晦涩。
+ XML&SOAP
    - XML是一种常用的序列化和反序列化协议，具有跨机器，跨语言等优点。
    - SOAP（Simple Object Access protocol） 是一种被广泛应用的，基于XML为序列化和反序列化协议的结构化消息传递协议。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。
+ JSON（Javascript Object Notation）
    - 这种Associative  array格式非常符合工程师对对象的理解。
    - 它保持了XML的人眼可读（Human-readable）的优点。
    - 相对于XML而言，序列化后的数据更加简洁。
    - 它具备Javascript的先天性支持，所以被广泛应用于Web   browser的应用常景中，是Ajax的事实标准协议。
    - 与XML相比，其协议比较简单，解析速度比较快。
    - 松散的Associative  array使得其具有良好的可扩展性和兼容性。
+ Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架，其产生正是为了满足当前大数据量、分布式、跨语言、跨平台数据通讯的需求。Thrift在空间开销和解析性能上有了比较大的提升，对于对性能要求比较高的分布式系统，它是一个优秀的RPC解决方案；但是由于Thrift的序列化被嵌入到Thrift框架里面，Thrift框架本身并没有透出序列化和反序列化接口，这导致其很难和其他传输层协议共同使用
+ Protobuf具备了优秀的序列化协议的所需的众多典型特征
    - 标准的IDL和IDL编译器，这使得其对工程师非常友好。
    - 序列化数据非常简洁，紧凑，与XML相比，其序列化之后的数据量约为1/3到1/10。
    - 解析速度非常快，比对应的XML快约20-100倍。
    - 提供了非常友好的动态库，使用非常简介，反序列化只需要一行代码。由于其解析性能高，序列化后数据量相对少，非常适合应用层对象的持久化场景
+ Avro的产生解决了JSON的冗长和没有IDL的问题，Avro属于Apache Hadoop的一个子项目。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，JSON格式方便测试阶段的调试。适合于高性能的序列化服务。

几种协议的对比

+ XML序列化（Xstream）无论在性能和简洁性上比较差；
+ Thrift与Protobuf相比在时空开销方面都有一定的劣势；
+ Protobuf和Avro在两方面表现都非常优越。

### 如果你定义一个类，包括学号，姓名，分数，如何把这个对象作为key？要重写equals和hashcode吗？
需要重写equals方法和hashcode，必须保证对象的属性改变时，其hashcode不能改变。

### ⽗类的静态⽅法能否被⼦类重写，为什么？（猎豹） 
⽗类的静态⽅法是不能被⼦类重写的，其实重写只能适⽤于实例⽅法，不能⽤于静态⽅法，对于上⾯这种静态⽅法⽽⾔，我们应该称之为隐藏。 

Java静态⽅法形式上可以重写，但从本质上来说不是Java的重写。因为静态⽅法只与类相关，不与具体实现相关。声明的是什么类，则引⽤相应类的静态⽅法(本来静态⽆需声明，可以直接引⽤)。并且static⽅法不是后期绑定的，它在编译期就绑定了。换句话说，这个⽅法不会进⾏多态的判断，只与声明的类有关。

### 继承和聚合的区别在哪？
+ **继承**

继承指的是一个类继承另外的一个类的功能，并可以增加它自己的新功能的能力；

继承是类与类或者接口与接口之间最常见的关系；

在Java中此类关系通过关键字extends明确标识；

在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性。

![20210303101144378.png](./img/jlawb-ju2rf3fWw4/1664599398992-c2f2607d-a91b-4971-8357-67fdf3e0c895-439964.png)

+ **聚合**

聚合指的是聚合体现的是整体与部分、拥有的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期；

比如计算机与CPU、公司与员工的关系等；

表现在代码层面，和关联关系是一致的，只能从语义级别来区分。

![20210303101158677.png](./img/jlawb-ju2rf3fWw4/1664599450757-18d77cb8-a273-413f-85e9-92c2b337c83d-690822.png)

> [继承和聚合的区别在哪？_ZhangSan_Plus的博客-CSDN博客_继承和聚合的区别在哪](https://blog.csdn.net/qq_43565087/article/details/114300698)
>

### 如何在父类中为子类自动完成所有的hashcode()和equals()实现？这么做有何优劣？
hashCode与equals方法都是Java Object 对象中的方法，也就是说Java的一切对象都提供这两个方法，

这两个方法在Java中有着不一般的联系。

在Java类操作中，hashcode()和equals()起着至关重要的计算依据，当集合要添加新的元素时，先调用这个元素的hashCode()方法，就能定位到它应该放置的物理位置上。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了。

如果这个位置上已经有元素了，就调用它的equals()方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。 

所以，这里存在一个冲突解决的过程。

好处：我们不用自己去写。

缺点：有时候父类中 equals()和hashcode()方法不满足我们的需求，需要重写。

hashCode()是所有java对象的固有方法。如果不重载的话，返回的实际上是该对象在jvm堆上的内存地址，而不同对象的内存地址肯定不同，所以这个hashCode也就肯定不同了。如果重载了的话，由于采用的算法的问题，有可能导致两个不同对象的hashCode相同。

java中的hash函数返回的是int类型的，也就是说，最多允许存在2^32个分组，也是有限的，所以出现相同的哈希码就不稀奇了。

### 深拷贝和浅拷贝区别
> [深拷贝和浅拷贝的区别_crystal_hhj的博客-CSDN博客_深拷贝和浅拷贝的区别](https://blog.csdn.net/crystal_hhj/article/details/119740469)
>

### 深拷贝和浅拷贝
浅拷贝就是对对象中的数据成员进行简单复制，如果存在动态成员或者指针就会报错。

深拷贝就是对对象中存在的动态成员或指针重新开辟内存空间。

### 说一说你对java.lang.Object对象中hashCode和equals方法的理解，在什么场景下需要重新实现这两个方法
> [关于java中Object类中的equals()和hashCode()方法的使用个人总结 - 张森（ZhangSen） - 博客园](https://www.cnblogs.com/nesnes/p/9863664.html)
>
> [Java 中什么时候需要重写hashCode()和equals()方法_Tom098的博客-CSDN博客_什么时候重写equals和hashcode](https://blog.csdn.net/Tom098/article/details/116711187)
>

###  在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题？
> [28.在 jdk1.5 中，引入了泛型，泛型的存在是用来解决什么问题_面试题库的博客-CSDN博客_泛型的存在是用来解决什么问题](https://blog.csdn.net/mianshitiku/article/details/118254465)
>

### 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。
> [HashCode和Equals的关系_江寸山的博客-CSDN博客_hashcode和equals的关系](https://blog.csdn.net/weixin_44664277/article/details/104289327)
>

### 有没有可能2个不相等的对象有相同的hashcode?
> [有没有可能两个不相等的对象有相同的hashcode，如何解决？_三郎君的博客-CSDN博客_有没有可能两个不相等的对象有相同的hashcode](https://blog.csdn.net/m0_51684972/article/details/109174708)
>

### 什么是序列化？怎么序列化？为什么序列化？反序列化会遇到什么问题？如何解决？
> [什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。_洒家肉山大魔王的博客-CSDN博客](https://blog.csdn.net/qq_27706119/article/details/123024021)
>

### 继承限制
父类对象不可以赋给子类对象，因为子类可能具有更多的成员，反之可以。

### Java 命名规范
必须以英文字母、下划线（’_’）或’$’开始，其余可以有数字但不允许包含空格，且组合后的名称不能是Java 关键字或保留字。

匈牙利命名法：以m 开始为类成员变量，以g 开始为全局变量，以v 开始为本地局部变量，常量命名一般不以下划线、美元符开始。

驼峰命名：一般称由多个单词或缩写组成的变量名，并且该变量名每个单词首字母均为大写（一般类名全部首字母大写，方法或属性名第一个字母小写）的称为驼峰命名。

### 简述类的关系
1） 当一个类是“一种”另一个类时：is-a 关系

2） 当两个类之间有关联时：

一个类“包含”另一个类：has-a 关系一个类“使用”另一个类还可以细分有聚合和组合（UML 宝典）或聚集和组成（包括国内某些知名学术团体都这么说）。

聚集（aggregation）表示整体与各部分之间的关系。例如汽车与轮胎，没有了汽车轮胎依然是一个整体。（用空心菱形表示）

组成是一种整体和部分所属更强的聚集关系，每个部分只能属于一个整体，没有整体部分也就没有存在的价值。比如桌子和桌腿，没有桌子也就没有桌腿的价值了。（用实心菱形表示）

### 讲讲深拷贝和浅拷贝？  
**浅拷贝**：拷⻉对象和原始对象的引⽤类型引用同⼀个对象。

以下例子，Cat对象里面有个Person对象，调用clone之后，克隆对象和原对象的Person引用的是同一个对象，这就是浅拷贝。

<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Cat</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Cloneable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>


<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">clone</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">CloneNotSupportedException</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kd">super</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">CloneNotSupportedException</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">Cat</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Cat</span><span class="p">();</span>
<span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;程序员大彬&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">c</span><span class="p">.</span><span class="na">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>


<span class="w">        </span><span class="n">Cat</span><span class="w"> </span><span class="n">cloneCat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Cat</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span>
<span class="w">        </span><span class="n">p</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span><span class="s">&quot;大彬&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">cloneCat</span><span class="p">.</span><span class="na">owner</span><span class="p">.</span><span class="na">getName</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//output</span>
<span class="w">    </span><span class="c1">//大彬</span>
<span class="p">}</span>
</code></pre></div>

**深拷贝**：拷贝对象和原始对象的引用类型引用不同的对象。

以下例子，在clone函数中不仅调用了super.clone，而且调用Person对象的clone方法（Person也要实现Cloneable接口并重写clone方法），从而实现了深拷贝。可以看到，拷贝对象的值不会受到原对象的影响。

<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Cat</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Cloneable</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="n">owner</span><span class="p">;</span>


<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">protected</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">clone</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">CloneNotSupportedException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Cat</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span>
<span class="w">        </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Cat</span><span class="p">)</span><span class="w"> </span><span class="kd">super</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span>
<span class="w">        </span><span class="n">c</span><span class="p">.</span><span class="na">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Person</span><span class="p">)</span><span class="w"> </span><span class="n">owner</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span><span class="c1">//拷贝Person对象 return c;</span>
<span class="w">    </span><span class="p">}</span>


<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">CloneNotSupportedException</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Cat</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Cat</span><span class="p">();</span>
<span class="w">        </span><span class="n">Person</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Person</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;程序员大彬&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">c</span><span class="p">.</span><span class="na">owner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>


<span class="w">        </span><span class="n">Cat</span><span class="w"> </span><span class="n">cloneCat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Cat</span><span class="p">)</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="na">clone</span><span class="p">();</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="na">setName</span><span class="p">(</span><span class="s">&quot;大彬&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">cloneCat</span><span class="p">.</span><span class="na">owner</span><span class="p">.</span><span class="na">getName</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//output</span>
<span class="w">    </span><span class="c1">//程序员大彬</span>
<span class="p">}</span>
</code></pre></div>

### 两个对象的hashCode()相同，则equals()是否也一定为true？  
equals与hashcode的关系：

1. 如果两个对象调用equals比较返回true，那么它们的hashCode值一定要相同；

2. 如果两个对象的hashCode相同，它们并不一定相同。

hashcode方法主要是用来**提升对象比较的效率**，先进行hashcode()的比较，如果不相同，那就不必在进行equals的比较，这样就大大减少了equals比较的次数，当比较对象的数量很大的时候能提升效率。

之所以重写equals() 要重写hashcode() ，是为了保证equals() 方法返回true的情况下hashcode值也要一致，如果重写了equals() 没有重写hashcode() ，就会出现两个对象相等但hashcode() 不相等的情况。这样，当用其中的一个对象作为键保存到hashMap、hashTable或hashSet中，再以另一个对象作为键值去查找他们的时候，则会查找不到。

### 如何实现对象克隆？
实现Cloneable 接口，重写   方法。这种方式是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。如果对象的属性的Class也实现Cloneable接口，那么在克隆对象时也会克隆属性，即深拷贝。

结合序列化，深拷贝。

通过org.apache.commons 中的工具类BeanUtils 和PropertyUtils 进行对象复制。

### 什么是序列化和反序列化？
序列化：把内存中的对象转换为字节序列的过程。反序列化：把字节序列恢复为Java对象的过程。

### 如何实现序列化？
实现Serializable 接口即可。序列化的时候（如objectOutputStream.writeObject(user) ），会判断user是否实现了Serializable，如果对象没有实现Serializable 接口，在序列化的时候会抛出NotSerializableException 异常。源码如下：

<div class="highlight"><pre><span></span><code><span class="c1">// remaining cases</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">String</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">writeString</span><span class="p">((</span><span class="n">String</span><span class="p">)</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">unshared</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cl</span><span class="p">.</span><span class="na">isArray</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">writeArray</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="n">unshared</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">Enum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">writeEnum</span><span class="p">((</span><span class="n">Enum</span><span class="o">&lt;?&gt;</span><span class="p">)</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="n">unshared</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">obj</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">Serializable</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">writeOrdinaryObject</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="w"> </span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="n">unshared</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">extendedDebugInfo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NotSerializableException</span><span class="p">(</span>
<span class="w">            </span><span class="n">cl</span><span class="p">.</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;\n&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debugInfoStack</span><span class="p">.</span><span class="na">toString</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NotSerializableException</span><span class="p">(</span><span class="n">cl</span><span class="p">.</span><span class="na">getName</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

### 如何将一个 Java 对象序列化到文件里？ 
ObjectOutputStream.writeObject()负责将指定的流写入，ObjectInputStream.readObject()从指定流读取序列化数据。 

<div class="highlight"><pre><span></span><code><span class="c1">//写入 </span>
<span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">ObjectOutputStream</span><span class="w"> </span><span class="n">os</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ObjectOutputStream</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">FileOutputStream</span><span class="p">(</span><span class="s">&quot;D:/student.txt&quot;</span><span class="p">));</span><span class="w"> </span>
<span class="w">    </span><span class="n">os</span><span class="p">.</span><span class="na">writeObject</span><span class="p">(</span><span class="n">studentList</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">os</span><span class="p">.</span><span class="na">close</span><span class="p">();</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="p">(</span><span class="n">FileNotFoundException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w"> </span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="p">(</span><span class="n">IOException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>

### 讲讲什么是泛型？
Java泛型是JDK 5中引⼊的⼀个新特性，允许在定义类和接口的时候使⽤类型参数。声明的类型参数在使

⽤时⽤具体的类型来替换。

泛型最⼤的好处是可以提⾼代码的复⽤性。以List接口为例，我们可以将String、 Integer等类型放⼊List中， 如不⽤泛型， 存放String类型要写⼀个List接口， 存放Integer要写另外⼀个List接口， 泛型可以很好的解决这个问题。

### 泛型常用特点
+ 泛型是类、结构、接口和方法所存储或使用的一个或多个类型的**占位符**。
+ 使用泛型类型可以最大限度地**重用代码**、**保护类型的安全**以及**提高性能**。
+ 泛型的好处是**在编译的时候检查类型安全**。
+ 泛型是通过**类型擦除**来实现的。

> 编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。List<String>不能转为List<Object>，因为泛型的类型不一样，这种转换只能在子类与父类之间转换，虽然Object是String的父类，但是List<Object>和List<String>在编译器看来，是两种完全不同的东西，不允许你这样转换。并没有什么父子类的关系，仅仅是表示一个用来装Obejct型对像，一个用来装String。
>
> 原文链接：[https://blog.csdn.net/qiuchaoxi/article/details/79858684](https://blog.csdn.net/qiuchaoxi/article/details/79858684)
>

> 泛型将接口的概念进一步延伸，“泛型”的字面意思就是广泛的类型。类、接口和方法代码可以应用于非常广泛的类型，代码与它们能够操作的数据类型不再绑定在一起，同一套代码可以用于多种数据类型，这样，不仅可以复用代码，降低耦合，而且可以提高代码的可读性和安全性。
>
> 摘自《Java编程的逻辑》第8章
>

### 知道范型的实现机制吗？
泛型的本质是参数化类型，就是将原来的具体的类型参数化。在不确定需要类型的情况下，通过泛型来指定具体的限制。

Java 的实现机制就是类型擦除，在编译的时候被擦除为 Obect。

> [Java | 泛型实现机制_Tʀᴜsᴛ³⁴⁵的博客-CSDN博客_java泛型的实现机制](https://blog.csdn.net/baidu_40389775/article/details/123309045)
>
> [泛型概述(下)：泛型实现机制](https://zhuanlan.zhihu.com/p/255264414)
>

### 👉谈谈你对解析与分派的认识
解析指方法在运行前，即编译期间就可知的，有一个确定的版本，运行期间也不会改变。解析是静态的，在类加载的解析阶段就可将符号引用转变成直接引用。 

分派可分为静态分派和动态分派，重载属于静态分派，覆盖属于动态分派。静态分派是指在重载时通过参数的静态类型而非实际类型作为判断依据，在编译阶段，编译器可根据参数的静态类型决定使用哪一个重载版本。动态分派则需要根据实际类型来调用相应的方法。 

### 说说你对 Java 注解的理解 
注解是通过@interface关键字来进行定义的，形式和接口差不多，只是前面多了一个@。

<div class="highlight"><pre><span></span><code><span class="kd">public</span><span class="w"> </span><span class="nd">@interface</span><span class="w"> </span><span class="n">TestAnnotation</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>

使用时@TestAnnotation 来引用，要使注解能正常工作，还需要使用元注解，它是可以注解到注解上的注解。元标签有@Retention、@Documented、@Target、@Inherited、@Repeatable 五种 

+ @Retention

说明注解的存活时间，取值有 RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时被丢弃；

RetentionPolicy.CLASS 注解只保留到编译进行的时候，并不会被加载到 JVM 中；RetentionPolicy.RUNTIME 可以留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。 

+ @Documented

注解中的元素包含到 javadoc 中去 

+ @Target

限定注解的应用场景，ElementType.FIELD 给属性进行注解； 

ElementType.LOCAL_VARIABLE 可以给局部变量进行注解；

ElementType.METHOD 可以给方法进行注解；

ElementType.PACKAGE 可以给一个包进行注解 ElementType.TYPE 可以给一个类型进行注解，如类、接口、枚举。

+ @Inherited

若一个超类被@Inherited 注解过的注解进行注解，它的子类没有被任何注解应用的话，该子类就可继承超类的注解。

**注解的作用： **

1）提供信息给编译器：编译器可利用注解来探测错误和警告信息；

2）编译阶段：软件工具可以利用注解信息来生成代码、html 文档或做其它相应处理； 

3）运行阶段：程序运行时可利用注解提取代码；

注解是通过反射获取的，可以通过 Class 对象的 isAnnotationPresent()方法判断它是否应用了某个注解，再通过 getAnnotation()方法获取 Annotation 对象。

### 注解
注解常用于登录、权限拦截、日志处理，以及各种Java框架，如Spring，Hibernate，JUnit。

提到注解就不能不说反射，Java自定义注解是通过运行时靠反射获取的。实际开发中，例如我们要获取某个方法的调用日志，可以通过AOP（动态代理机制）给方法添加切面，通过反射来获取方法包含的注解，如果包含日志注解，就进行日志记录。

![1663838098588-8256c56b-492f-4f15-92fa-539202aa4c6b.png](./img/jlawb-ju2rf3fWw4/1663838098588-8256c56b-492f-4f15-92fa-539202aa4c6b-463623.png)

### Cloneable 接口实现原理
Cloneable接口是Java开发中常用的一个接口，它的作用是使一个类的实例能够将自身拷贝到另一个新的实例中，注意，这里所说的“拷贝”拷的是对象实例，而不是类的定义，进一步说，拷贝的是一个类的实例中各字段的值。 

> 在开发过程中，拷贝实例是常见的一种操作，如果一个类中的字段较多，而我们又采用在客户端中逐字段复制的方法进行拷贝操作的话，将不可避免的造成客户端代码繁杂冗长，而且也无法对类中的私有成员进行复制，而如果让需要具备拷贝功能的类实现Cloneable接口，并重写clone()方法，就可以通过调用clone()方法的方式简洁地实现实例拷贝功能
>

深拷贝(深复制)和浅拷贝(浅复制)是两个比较通用的概念，尤其在C++语言中，若不弄懂，则会在delete的时候出问题，但是我们在这幸好用的是Java。虽然Java自动管理对象的回收，但对于深拷贝(深复制)和浅拷贝(浅复制)，我们还是要给予足够的重视，因为有时这两个概念往往会给我们带来不小的困惑。 

浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象 A1 中包含对 B1 的引用， B1 中包含对 C1 的引用。浅拷贝 A1 得到 A2 ， A2 中依然包含对 B1 的引用， B1 中依然包含对 C1 的引用。深拷贝则是对浅拷贝的递归，深拷贝 A1 得到 A2 ， A2 中包含对 B2 （ B1 的 copy ）的引用， B2 中包含对 C2 （ C1 的 copy ）的引用。

若不对clone()方法进行改写，则调用此方法得到的对象即为浅拷贝

### 说一下泛型原理，并举例说明
泛型就是将类型变成参数传入，使得可以使用的类型多样化，从而实现解耦。Java 泛型是在Java1.5 以后出现的，为保持对以前版本的兼容，使用了擦除的方法实现泛型。擦除是指在一定程度无视类型参数 T，直接从 T 所在的类开始向上 T 的父类去擦除，如调用泛型方法，传入类型参数 T 进入方法内部，若没在声明时做类似 public T methodName(T extends Father t){}，Java 就进行了向上类型的擦除，直接把参数 t 当做 Object 类来处理，而不是传进去的 T。 

即在有泛型的任何类和方法内部，它都无法知道自己的泛型参数，擦除和转型都是在边界上发生，即传进去的参在进入类或方法时被擦除掉，但传出来的时候又被转成了我们设置的 T。 

在泛型类或方法内，任何涉及到具体类型（即擦除后的类型的子类）操作都不能进行，如new T()，或者 T.play()（play 为某子类的方法而不是擦除后的类的方法） 

### 序列化 Serializable 和 Parcelable 的区别 
**序列化**：将一个对象转换成可存储或可传输的状态，序列化后的对象可以在网络上传输，也可以存储到本地，或实现跨进程传输； 

**为什么要进行序列化**：开发过程中，我们需要将对象的引用传给其他 activity 或 fragment 使用时，需要将这些对象放到一个 Intent 或 Bundle 中，再进行传递，而 Intent 或 Bundle只能识别基本数据类型和被序列化的类型。

**Serializable**：表示将一个对象转换成可存储或可传输的状态。 

**Parcelable**：与 Serializable 实现的效果相同，也是将一个对象转换成可传输的状态，但它的实现原理是将一个完整的对象进行分解，分解后的每一部分都是 Intent 所支持的数据类型，这样实现传递对象的功能。 

**Parcelable 实现序列化的重要方法**：序列化功能是由 writeToParcel 完成，通过 Parcel 中的 write 方法来完成；反序列化由 CREATOR 完成，内部标明了如何创建序列化对象及数级，通过 Parcel 的 read 方法完成；内容描述功能由 describeContents 方法完成，一般直接返回 0。 

**区别**：Serializable 在序列化时会产生大量临时变量，引起频繁 GC。Serializable 本质上使用了反射，序列化过程慢。Parcelable 不能将数据存储在磁盘上，在外界变化时，它不能很好的保证数据的持续性。 

**选择原则**：若仅在内存中使用，如 activity\service 间传递对象，优先使用 Parcelable，它性能高。若是持久化操作，优先使用 Serializable 

**注意**：静态成员变量属于类，不属于对象，固不会参与序列化的过程；用 transient 关键字编辑的成员变量不会参与序列化过程；可以通过重写 writeObject()和 readObject()方法来重写系统默认的序列化和反序列化。

### java 域的概念
field，域是一种属性，可以是一个类变量量，⼀个对象变量量，⼀个对象⽅法变量或者是⼀个函数的参数。

### 静态属性和静态方法是否可以被继承？ 
静态是指在编译时就会分配内存且一直存在，跟对象实例无关。

### 静态变量和实例变量的区别？
静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。在Java开发中，上下文类和工具类中通常会有大量的静态成员。

### 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？
不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化。

### 数组有没有length()方法？String 有没有length()方法？
数组没有length()方法，有length 的属性。String 有length()方法。JavaScript中，获得字符串的长度是通过length属性得到的，这一点容易和Java混淆。

![1664380327538-b2d15e88-e7f3-44f7-a81b-54778067c366.png](./img/jlawb-ju2rf3fWw4/1664380327538-b2d15e88-e7f3-44f7-a81b-54778067c366-533109.png)

### 两个对象值相同(x.equals(y) == true)，但却可有不同的hashcode，这句话对不对？
不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。

补充：关于equals和hashCode方法，很多Java程序都知道，但很多人也就是仅仅知道而已，在Joshua Bloch的大作《Effective Java》（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍）中是这样介绍equals方法的：首先equals方法必须满足自反性（x.equals(x)必须返回true）、对称性（x.equals(y)返回true时，y.equals(x)也必须返回true）、传递性（x.equals(y)和y.equals(z)都返回true时，x.equals(z)也必须返回true）和一致性（当x和y引用的对象信息没有被修改时，多次调用x.equals(y)应该得到同样的返回值），而且对于任何非null值的引用x，x.equals(null)必须返回false。实现高质量的equals方法的诀窍包括：

1. 使用==操作符检查“参数是否为这个对象的引用”；

2. 使用instanceof操作符检查“参数是否为正确的类型”；

3. 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；

4. 编写完equals方法后，问自己它是否满足对称性、传递性、一致性；

5. 重写equals时总是要重写hashCode；

6. 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解。

### 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。

补充：Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。

### 如何实现对象克隆？
有两种方式：

1.实现Cloneable接口并重写Object类中的clone()方法；

2.实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下。

![1664380521972-00e34854-a8d9-46c4-b792-a4a54c422b05.png](./img/jlawb-ju2rf3fWw4/1664380521972-00e34854-a8d9-46c4-b792-a4a54c422b05-881045.png)

注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。

### 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。

### 指出下面程序的运行结果
![1664380562798-83ef5288-dec3-4b40-ac87-3c7131524265.png](./img/jlawb-ju2rf3fWw4/1664380562798-83ef5288-dec3-4b40-ac87-3c7131524265-512484.png)  
执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。

### 日期和时间
1)如何取得年月日、小时分钟秒？

2)如何取得从1970年1月1日0时0分0秒到现在的毫秒数？

3)如何取得某月的最后一天？

4)如何格式化日期？

操作方法如下所示：

1)创建java.util.Calendar 实例，调用其get()方法传入不同的参数即可获得参数所对应的值

2)以下方法均可获得该毫秒数:

![1664380594786-e228ae56-ce99-4df3-8a01-87cd406b5c73.png](./img/jlawb-ju2rf3fWw4/1664380594786-e228ae56-ce99-4df3-8a01-87cd406b5c73-495922.png)

3)示例代码如下:

![1664380604753-b32a5847-c64b-484a-a92f-513848924304.png](./img/jlawb-ju2rf3fWw4/1664380604753-b32a5847-c64b-484a-a92f-513848924304-724064.png)

4)利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化。

### 打印昨天的当前时刻
![1664380618678-565b4a44-fc94-4c77-afe2-18b7d6b01c4d.png](./img/jlawb-ju2rf3fWw4/1664380618678-565b4a44-fc94-4c77-afe2-18b7d6b01c4d-109797.png)

### JNI的使用
**jni是一种协议**，这个协议用来**沟通java代码和外部的本地代码（c/c++）**，通过这个协议，java代码就可以调用外部的c++代码。

1、在java本地代码中声明一个native方法：例如：`public native String helloJni();`

2、在eclipse中创建一个文件夹，名称**必须命名为jni**；

3、在jni这个文件夹下创建一个.c文件，按照c代码的规范来写

4、ndk-build.cmd指令编译c代码（注意：如果不配置Android.mk文件的话就会报错）；

5、配置Android.mk文件；

6、编译过后，自动生成一个.so的动态链接库；

7、在java代码中，把动态链接库加载到jvm虚拟机中加入一个静态代码块

8、像调用java代码一样，调用native方法。

### 面向对象开发的六个基本原则(单一职责、开放封闭、里氏替换、依赖倒置、合成聚合复用、接口隔离)，迪米特法则。在项目中用过哪些原则
+ **六个基本原则**
    - 单一职责：一个类只做它该做的事情(高内聚)。在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。
    - 开放封闭：软件实体应当对扩展开放，对修改关闭。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱。
    - 里氏替换：任何时候都可以用子类型替换掉父类型。子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。
    - 依赖倒置：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代）
    - 合成聚和复用：优先使用聚合或合成关系复用代码。
    - 接口隔离：接口要小而专，绝不能大而全。臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。
+ **迪米特法则**

迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。

+ **项目中用到的原则**
    - 单一职责
    - 开放封闭
    - 合成聚合复用(最简单的例子就是String类)
    - 接口隔离

### 33.谈谈你对深克隆和浅克隆的理解
一个工作了 5 年的程序员私信我说，前几天去阿里面试被问到这样一个这样的面试题，说谈谈你对深克隆和浅克隆的理解。他回答说深克隆是克隆值，浅克隆是克隆引用，当时他只说了这样一句话，回答完以后，他看到面试官的表情很诧异，面试也没有继续深入追问了。小伙伴们，如果是你来回答，你也会这样回答吗？

这位小伙伴的回答并没有错，只是面试官觉得回答得有点抽象而已。今天，我给大家详细聊一聊。

另外，我花了 1 个多星期把往期的面试题解析配套文档准备好了，想获取的小伙伴可以在我的煮叶简介中找到。

说到克隆啊，我还不得不说到一个设计模式，原型模式。

先来看原型模式的定义。

#### 1、原型模式定义
原型模式的官方原文是这样的：

![1671096041309-d462efaa-b82d-4f06-bf70-ab50cd1197f8.png](./img/jlawb-ju2rf3fWw4/1671096041309-d462efaa-b82d-4f06-bf70-ab50cd1197f8-467133.png)

大致意思是，指原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。其实复制、克隆、拷贝表达的都是同一个意思。因为 Java 中的数据类型分为引用类型和值类型，因此，在克隆数据的过程中，就有了深克隆和浅克隆。

#### 2、深克隆和浅克隆
那么，深克隆和浅克隆的本质区别又是什么呢？ 我归纳为以下两点：

第 1 点： 看数据拷贝后两者之间是否有关联。

第 2 点： 改变一个值是否会影响到另一个值变化。

![1671096077082-416744dd-cf64-4c23-8d6f-7a98adc17fd6.png](./img/jlawb-ju2rf3fWw4/1671096077082-416744dd-cf64-4c23-8d6f-7a98adc17fd6-717366.png)

那么，到底什么是深克隆，什么是浅克隆呢？

先来看浅克隆，浅克隆就是数据拷贝后，一方数据变化另一方会跟着变化。

如图所示： 有原型对象 Object，它是引用类型，然后拷贝后产生两个克隆对象 obj1 和 obj2，只是它们克隆的是 Object的内存地址，因此 ob1 和 obj2 都指向 Object，那么 Object中的成员变量值发生改变时，obj1 和 obj2 指向的成员变量值也就会发生改变。

![1671096103834-2fa51696-55dd-472e-aca5-346fac3a2265.png](./img/jlawb-ju2rf3fWw4/1671096103834-2fa51696-55dd-472e-aca5-346fac3a2265-505511.png)

实现浅克隆的常用 API 有以下 3 种，

1 、工具类 BeanUtils 和 PropertyUtils，BeanUtils 是 Spring 提供的，PropertyUtils 是 Apache 的 commons 包中提供的。

2 、实现 Clonenable 接口

3 、Arrays 的 copyOf()方法

![1671096116766-24b713f1-983d-4797-9e43-ac217f694b9c.png](./img/jlawb-ju2rf3fWw4/1671096116766-24b713f1-983d-4797-9e43-ac217f694b9c-077369.png)

下面来看深克隆，深克隆就是数据拷贝后，原型对象和克隆对象之间没有关联。如图所示： obj1 和 obj2 分别指向不同的原型对象，拷贝的是值不是内存地址。

![1671096128628-948ae02f-b48f-40d1-8f68-36aaca8cc48f.png](./img/jlawb-ju2rf3fWw4/1671096128628-948ae02f-b48f-40d1-8f68-36aaca8cc48f-614019.png)

深克隆常用的 API 有以下 5 种：

1 、重写 clone()方法

2、序列化

3、Apache commons 工具包中的SerializationUtils 的 clone() 方法

4、JSON 工具类

5 、通过构造方法手动 new 对象。

![1671096148163-61de9550-c754-4fd3-855d-dfbfecd96f98.png](./img/jlawb-ju2rf3fWw4/1671096148163-61de9550-c754-4fd3-855d-dfbfecd96f98-753210.png)

### 104.请你对比一下 Java 和 JavaScript的区别
一位应届生在面试的时候把所有的八股文都答对了。没成想，有位面试官出了个奇招，面试官问了一句说，请你对比一下Java和JavaScript的区别。我这想这样入门级别的问题，应该每一个后端开发人员都能答得上吧。没成想，有位应届毕业生竟然没有答出来，还说JavaScript 是对Java 的升级。这样的回答，实在是有点不应该。

今天呢，我给大家总结一下Java 和JavaScript 的异同之处，

#### 1、两者不同之处
首先总结两者不同之处，我从以下4 个方面来进行分析：

![1671122769329-37fe7758-f1b6-467e-a66c-2745b280783a.png](./img/jlawb-ju2rf3fWw4/1671122769329-37fe7758-f1b6-467e-a66c-2745b280783a-069627.png)

1）产生背景不同

![1671122776153-68801a2d-a379-437e-a749-16c392efee45.png](./img/jlawb-ju2rf3fWw4/1671122776153-68801a2d-a379-437e-a749-16c392efee45-954733.png)

最初 Java 语言是由Sun公司研发，前身叫 Oak 语言，1995年5月正式对外发布并开源，特别 。

而JavaScript是Netscape（网景）公司的产品，最初被名命名为LiveScript。为了扩展Netscape 浏览器的功能而开发的解释性语言。

因为Netscape与Sun合作，Netscape（网景）公司管理层希望它外观看起来像Java，因此取名为JavaScript。

![1671122805159-c898f9ea-688b-4268-bf8f-95606d7c7838.png](./img/jlawb-ju2rf3fWw4/1671122805159-c898f9ea-688b-4268-bf8f-95606d7c7838-805556.png)

2）对象设计不同

![1671122814075-d7aa4e9d-480a-42a0-b3d1-aebb6e2eabf4.png](./img/jlawb-ju2rf3fWw4/1671122814075-d7aa4e9d-480a-42a0-b3d1-aebb6e2eabf4-905427.png)

Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；

而JavaScript 是脚本语言，可以用来开发与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，它内置了非常丰富的对象供开发人员使用。

![1671122826926-00e08f2e-fa9a-415e-98e0-c3a83542a5f6.png](./img/jlawb-ju2rf3fWw4/1671122826926-00e08f2e-fa9a-415e-98e0-c3a83542a5f6-932875.png)

3）运行机制不同

![1671122834271-4d41cc26-ca7c-47ae-b795-d4f4e9578ca6.png](./img/jlawb-ju2rf3fWw4/1671122834271-4d41cc26-ca7c-47ae-b795-d4f4e9578ca6-881607.png)

Java 的源代码在执行之前必须经过编译。

而JavaScript 是一种解释性编程语言，源代码不需经过编译，直接由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率）

![1671122848570-1e45fb6b-9d63-455d-9216-697a869edafb.png](./img/jlawb-ju2rf3fWw4/1671122848570-1e45fb6b-9d63-455d-9216-697a869edafb-014897.png)

4）变量定义不同

![1671122856608-e25d52c1-af5a-487c-8d8e-7d33ee2dcc79.png](./img/jlawb-ju2rf3fWw4/1671122856608-e25d52c1-af5a-487c-8d8e-7d33ee2dcc79-869738.png)

Java 采用强类型变量检查，也就是说，所有的变量在编译之前必须先声明；

而JavaScript 中变量是弱类型的，甚至在使用前变量可以不作声明。JavaScript 的解释器会在运行时自动判断数据类型。

#### 2、两者相同之处
当然，Java 和 JavaScript 也很多相同之处，我从以下几个方面来分析：

![1671122889153-0f7eb063-443f-4435-8a6b-1b9043da76fd.png](./img/jlawb-ju2rf3fWw4/1671122889153-0f7eb063-443f-4435-8a6b-1b9043da76fd-475723.png)

1）Java和JavaScript 的语法都和 C 语言都很相似；

2）都是面向对象的。虽然实现的方式略有不同，但是JavaScript 在设计时参照了 Java 的命名规则；

#### 3、总结
![1671122899499-86e0b02c-0057-4446-b895-0a5dcfc3ad99.png](./img/jlawb-ju2rf3fWw4/1671122899499-86e0b02c-0057-4446-b895-0a5dcfc3ad99-553850.png)

JavaScript 除了名字长得和 Java 比较像之外，它语言风格相差非常大。JavaScript 在设计时不仅参考了Java，还参考了 Self 和 Scheme 等其他语言。

Java和JavaScript 各有所长各有专精，Java的舞台在编程领域，而JavaScript的得心之处是在Web页面中，它几乎无所不能。

我上面列出的相同点和不同点都在网上流传的所谓的标准答案。

但是，我认为Java 和 JavaScript最重要的区别在于：JavaScript是静态语言，而Java是动态语言。

目前的编程语言的发展趋势是函数式语言和动态语言。在 Java 中，类（Class）是一等公民，而 JavaScript 中，函数（Function）是一等公民，因此 JavaScript 支持函数式编程，可以使用 Lambda函数和闭包（closure）。

当然，Java 8 也开始支持函数式编程，提供了对 Lambda表达式以及函数式接口的支持。对于这类问题，在面试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答案。

好了，以上就是我对Java 和JavaScript 的理解。





> 更新: 2023-08-08 23:36:59  
> 原文: <https://www.yuque.com/joyo/interview/nb6fhl>

?>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>