
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="褚成志">
      
      
        <link rel="canonical" href="http://blog.chucz.asia/Java/%E9%9B%86%E5%90%88/List/">
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>List - 褚成志的技术博客</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#list" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="褚成志的技术博客" class="md-header__button md-logo" aria-label="褚成志的技术博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            褚成志的技术博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              List
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="褚成志的技术博客" class="md-nav__button md-logo" aria-label="褚成志的技术博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    褚成志的技术博客
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    首页
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#arraylist" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList 了解吗？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist_1" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList 的扩容机制？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist_2" class="md-nav__link">
    <span class="md-ellipsis">
      怎么在遍历 ArrayList 时移除一个元素？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist-vector" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList 和 Vector 的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist-linkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList 与 LinkedList 的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#list-set" class="md-nav__link">
    <span class="md-ellipsis">
      List 和 Set 的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylistlinkedlistvector" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList、LinkedList、Vector 的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist-linkedlist_1" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList 与 LinkedList 区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist-vector_1" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList 与 Vector 区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist_3" class="md-nav__link">
    <span class="md-ellipsis">
      数组和 ArrayList 的区别
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist_4" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList 如何实现排序
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#list_1" class="md-nav__link">
    <span class="md-ellipsis">
      List 能怎样方便的排序？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist-linkedlist_2" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList 和 LinkedList 区分及实现原理
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vectorarraylist-linkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      Vector、ArrayList 和 LinkedList 的区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylistvectorlinkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      阐述ArrayList、Vector、LinkedList的存储性能和特性
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylistlinkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList和LinkedList有什么区别？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linkedlist-arraylist" class="md-nav__link">
    <span class="md-ellipsis">
      LinkedList 与 ArrayList 区别适用场景
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylistlinkedlist_forget_sky-csdn_arraylist-linkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList和LinkedList区别及使用场景_Forget_Sky的博客-CSDN博客_arraylist linkedlist
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#arraylist_5" class="md-nav__link">
    <span class="md-ellipsis">
      ArrayList 是如何扩容的？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#95-arraylist" class="md-nav__link">
    <span class="md-ellipsis">
      95.请你谈一谈 ArrayList自动扩容机制的实现原理
    </span>
  </a>
  
    <nav class="md-nav" aria-label="95.请你谈一谈 ArrayList自动扩容机制的实现原理">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    <span class="md-ellipsis">
      1 存储容器
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2 扩容原理
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#105arraylistvectorlinkedlist" class="md-nav__link">
    <span class="md-ellipsis">
      105.谈谈ArrayList、Vector和LinkedList 的存储性能及特性
    </span>
  </a>
  
    <nav class="md-nav" aria-label="105.谈谈ArrayList、Vector和LinkedList 的存储性能及特性">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    <span class="md-ellipsis">
      1、存储性能及特性
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2_1" class="md-nav__link">
    <span class="md-ellipsis">
      2、关于遗留容器
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vector" class="md-nav__link">
    <span class="md-ellipsis">
      Vector是一个线程安全类吗？
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="list">List</h1>
<h3 id="arraylist">ArrayList 了解吗？</h3>
<p>ArrayList 的底层是<strong>动态数组</strong>，它的容量能<strong>动态增长</strong>。在添加大量元素前，应用可以使用 ensureCapacity 操作增加 ArrayList 实例的容量。</p>
<p>ArrayList <strong>继承了 AbstractList</strong> ，并实现了 List 接口。</p>
<h3 id="arraylist_1">ArrayList 的扩容机制？</h3>
<p>ArrayList 扩容的本质就是<strong><u>计算出新的扩容数组的 size 后再实例化</u></strong>，最后<strong>将原有数组内容复制到新数组中</strong>去。 </p>
<p><strong>默认情况下，新的容量会是原容量的 1.5 倍</strong>。</p>
<p>以JDK1.8为例说明:</p>
<pre><code class="language-java">public boolean add(E e) {
    //判断是否可以容纳e，若能，则直接添加在末尾；
    //若不能，则进行扩容，然后再把e添加在末尾
    ensureCapacityInternal(size + 1); // Increments modCount!!
    //将e添加到数组末尾 
    elementData[size++] = e;
    return true;
}

// 每次在add()一个元素时，arraylist都需要对这个list的容量进行一个判断。
// 通过 ensureCapacityInternal()方法确保当前ArrayList维护的数组具有存储新元素的能力，
// 经过处理之后将元素存储在数组elementData的尾部

private void ensureCapacityInternal(int minCapacity) { 
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

private static int calculateCapacity(Object[] elementData, int minCapacity) {
    //如果传入的是个空数组则最小容量取默认容量与minCapacity之间的最大值 
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}

private void ensureExplicitCapacity(int minCapacity) { 
    modCount++;
    // 若ArrayList已有的存储能力满足最低存储要求，则返回add直接添加元素；
    // 如果最低要求的存储能力&gt;ArrayList已有的存储能力，这就表示ArrayList的存储能力不足，
    // 因此需要调用 grow()方法进行扩容
    if (minCapacity - elementData.length &gt; 0) 
        grow(minCapacity);
}

private void grow(int minCapacity) {
    // 获取elementData数组的内存空间长度
    int oldCapacity = elementData.length;
    // 扩容至原来的1.5倍
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    // 校验容量是否够
    if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity;
    // 若预设值大于默认的最大值，检查是否溢出
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity);
    // 调用Arrays.copyOf方法将elementData数组指向新的内存空间
    // 并将elementData的数据复制到新的内存空间
    elementData = Arrays.copyOf(elementData, newCapacity);
}
</code></pre>
<h3 id="arraylist_2">怎么在遍历 ArrayList 时移除一个元素？</h3>
<p>foreach 删除会导致<strong>快速失败</strong>问题，可以<strong>使用迭代器</strong>的<code>remove()</code>方法。</p>
<pre><code class="language-java">Iterator itr = list.iterator(); 
while(itr.hasNext()) {
    if(itr.next().equals(&quot;jay&quot;) { 
        itr.remove();
    }
}
</code></pre>
<h3 id="arraylist-vector">ArrayList 和 Vector 的区别</h3>
<ol>
<li>ArrayList 在内存不够时<strong>默认是扩展 50% + 1 个</strong>，<strong>Vector 是默认扩展 1 倍</strong>。</li>
<li>Vector 属于<strong>线程安全</strong>级别的，但是大多数情况下不使用 Vector，因为操作 Vector 效率比较低。</li>
</ol>
<h3 id="arraylist-linkedlist">ArrayList 与 LinkedList 的区别</h3>
<ol>
<li>ArrayList 基于<strong>动态数组</strong>实现；LinkedList 基于<strong>链表</strong>实现。</li>
<li>对于随机 index 访问的 get 和 set 方法，ArrayList 的速度要优于 LinkedList。因为 ArrayList 直接通过数组下标直接找到元素；LinkedList 要移动指针遍历每个元素直到找到为止。</li>
<li>新增和删除元素，LinkedList 的速度要优于 ArrayList。因为 ArrayList 在新增和删除元素时，可能扩容和复制数组；LinkedList 除了实例化对象需要时间外，只需要修改指针即可。</li>
</ol>
<h3 id="list-set">List 和 Set 的区别</h3>
<p>List、 Set 都是继承自 Collection 接口；</p>
<ul>
<li>List 特点：元素有放入顺序，元素可重复；</li>
<li>Set 特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（元素虽然无放入顺序，但是<u>元素在 set 中的位置是由该元素的 </u><strong><u>HashCode</u></strong><u> 决定的</u>，其位置其实是固定的，<strong>加入 Set 的 Object 必须定义 equals () 方法；</strong></li>
<li>List 支持 for 循环，也就是通过<strong>下标</strong>来遍历，也可以用<strong>迭代器</strong>，但是 set 只能用迭代器，因为他无序，无法用下标来取得想要的值。）</li>
<li>Set：<strong>检索元素效率低下</strong>，删除和插入效率高，<u>插入和删除不会引起元素位置改变</u>。 </li>
<li>List：和数组类似，List可以动态增长，查找元素效率高，<strong>插入删除元素效率低</strong>，因为会引起其他元素位置改变 </li>
</ul>
<h3 id="arraylistlinkedlistvector">ArrayList、LinkedList、Vector 的区别</h3>
<ul>
<li>ArrayList：线程不安全，数组，适合查找，<strong>可自动扩容 50%</strong>，<br />
三个构造器：无参，容量，Collection 接口；<br />
<code>transient Object[] elementData;</code>不会被序列化。</li>
<li>LinkedList：线程不安全，链表，适合插入、删除</li>
<li>Vector：线程安全，数组，适合查找，<strong>可自动扩容 100%</strong></li>
</ul>
<h3 id="arraylist-linkedlist_1"><strong>ArrayList 与 LinkedList 区别</strong></h3>
<ul>
<li><strong>ArrayList：</strong><ul>
<li><strong>优点：ArrayList 是实现了基于</strong><strong>动态数组</strong><strong>的数据结构。因为地址连续，一旦数据存储好了，查询操作效率会比较高（</strong><u>在内存里是连着放的</u><strong>）。</strong></li>
<li><strong>缺点：因为地址连续， ArrayList </strong><u>要移动数据</u><strong>，所以</strong><u>插入和删除操作效率比较低</u><strong>。</strong></li>
</ul>
</li>
<li><strong>LinkedList</strong><strong>：</strong><ul>
<li><strong>优点：LinkedList 基于</strong><strong>链表</strong><strong>的数据结构，地址是任意的，所以在</strong><u>开辟内存空间的时候不需要等一个连续的地址</u><strong>。</strong><u>对于新增和删除操作 add 和 remove，LinedList 比较占优势。</u><strong>LinkedList 适用于要</strong><strong>头尾操作</strong><strong>或</strong><strong>插入指定位置</strong><strong>的场景</strong></li>
<li><strong>缺点：因为 LinkedList 要移动指针，所以</strong><u>查询操作性能比较低</u><strong>。</strong></li>
</ul>
</li>
<li><strong>适用场景分析：</strong><ul>
<li><strong>当需要对数据进行多次访问的情况下选用 ArrayList；</strong></li>
<li><strong>当需要对数据进行多次增加删除修改时采用 LinkedList。</strong></li>
</ul>
</li>
</ul>
<h3 id="arraylist-vector_1"><strong>ArrayList 与 Vector 区别</strong></h3>
<pre><code class="language-plain">// 构造一个具有指定初始容量的空列表。
public ArrayList(int initialCapacity){//...}
// 构造一个初始容量为10的空列表。    
public ArrayList(){//...}
// 构造一个包含指定 collection 的元素的列表
public ArrayList(Collection&lt;?  extends E&gt; c){//...}

// Vector有四个构造方法：
// 使用指定的初始容量和等于零的容量增量构造一个空向量。
public Vector(){//...}
// 构造一个空向量，使其内部数据数组的大小，其标准容量增量为零。
public Vector(int initialCapacity){//...}
// 构造一个包含指定 collection 中的元素的向量
public Vector(Collection&lt;? extends E&gt; c){//...}
// 使用指定的初始容量和容量增量构造一个空的向量
public Vector(int initialCapacity,int capacityIncrement){//...}
</code></pre>
<p><strong>ArrayList 和 Vector 都是用</strong><strong>数组</strong><strong>实现的，主要有这么三个区别：</strong></p>
<ul>
<li><strong>Vector 是</strong><strong>多线程安全</strong><strong>的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而 ArrayList 不是，这个可以从源码中看出，Vector 类中的方法很多有</strong><strong> synchronized </strong><strong>进行修饰，这样就导致了 </strong><u>Vector 在效率上无法与 ArrayList 相比</u><strong>；</strong></li>
<li><strong>两个都是采用的</strong><strong>线性连续空间</strong><strong>存储元素，但是当空间不足的时候，两个类的</strong><u>扩容方式不同</u><strong>。</strong></li>
<li><u>Vector 可以设置增长因子</u><strong>，而 ArrayList 不可以。</strong></li>
</ul>
<p><strong>Vector 是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。</strong></p>
<p><strong>适用场景分析：</strong></p>
<p><strong>Vector 是线程同步的，所以它也是线程安全的，而 ArrayList 是线程异步的，是不安全的。</strong><u>如果不考虑到线程的安全因素，一般用ArrayList效率比较高</u><strong>。</strong></p>
<h3 id="arraylist_3">数组和 ArrayList 的区别</h3>
<ol>
<li>数组可以包含<strong>基本类型</strong>和<strong>对象类型</strong>，ArrayList 只能包含对象类型</li>
<li>数组<strong>大小固定</strong>，ArrayList 大小可以动态变化</li>
<li>ArrayList 提供了<strong>更多的特性</strong>（<code>addAll</code>、<code>removeAll</code>）。</li>
</ol>
<h3 id="arraylist_4">ArrayList 如何实现排序</h3>
<ul>
<li><code>Collections.sort(List&lt;T&gt; list)</code>;</li>
<li><code>Collections.sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>;</li>
<li>lambda 表达式：<code>list.stream().sort(Comparator)</code></li>
</ul>
<h3 id="list_1">List 能怎样方便的排序？</h3>
<ul>
<li>Collections.sort(comparator)</li>
<li>Collections.sort(list, comparator)</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/zsgCXB/article/details/122642652">List集合快捷排序_a-shu的博客-CSDN博客_list快速排序</a>
</p>
</blockquote>
<h3 id="arraylist-linkedlist_2">ArrayList 和 LinkedList 区分及实现原理</h3>
<ol>
<li>ArrayList 是实现了基于<strong>动态数组</strong>的数据结构，⽽LinkedList是基于<strong>链表</strong>的数据结构； </li>
<li>对于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 <u>LinkedList 要移动指针</u>； </li>
<li>对于添加和删除操作 add 和 remove，⼀般⼤家都会说 LinkedList 要⽐ ArrayList 快，因为 <u>ArrayList 要移动数据</u>。 </li>
</ol>
<h3 id="vectorarraylist-linkedlist">Vector、ArrayList 和 LinkedList 的区别？</h3>
<ol>
<li>Vector、ArrayList 都是以<strong>类似数组</strong>的形式存储在内存中，LinkedList则以<strong>链表</strong>的形式进行存储。</li>
<li>Vector 线程同步，ArrayList、LinkedList 线程不同步。</li>
<li>LinkedList 适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。</li>
<li>ArrayList 在元素填满容器时会自动扩充容器大小的 <strong>50%</strong>，而 Vector 则是<strong>100%</strong>，因此 ArrayList 更节省。</li>
</ol>
<h3 id="arraylistvectorlinkedlist">阐述ArrayList、Vector、LinkedList的存储性能和特性</h3>
<p>ArrayList 和Vector都是使用<strong>数组</strong>方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素。但是，插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。</p>
<p>总结：ArrayList是线程不安全的，Vector是线程安全的，故在性能上ArrayList比Vector要好。</p>
<p>LinkedList使用<strong>双向链表</strong>实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以<strong>插入速度较快</strong>。</p>
<p>总结：LinkedList是双向链表结构，在插入操作时不需要遍历所有数据，速度较快，其他操作时和ArrayList性能相同。</p>
<p>但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用。</p>
<blockquote>
<p><a href="https://www.likecs.com/show-203866881.html">列举java的集合和继承关系 - 爱码网</a>
</p>
</blockquote>
<h3 id="arraylistlinkedlist">ArrayList和LinkedList有什么区别？</h3>
<blockquote>
<p><a href="https://www.php.cn/faq/415621.html">linkedlist和arraylist的区别是什么-常见问题-PHP中文网</a></p>
<p><a href="https://blog.csdn.net/weixin_41657730/article/details/82462156">ArrayList与LinkList对比_Coder阿呆的博客-CSDN博客_linklist和arraylist</a>
</p>
</blockquote>
<h3 id="linkedlist-arraylist">LinkedList 与 ArrayList 区别适用场景</h3>
<ul>
<li>LinkedList：写多读少；</li>
<li>ArrayList：读多写少。</li>
</ul>
<blockquote>
<h3 id="arraylistlinkedlist_forget_sky-csdn_arraylist-linkedlist"><a href="https://blog.csdn.net/u012216131/article/details/82500925">ArrayList和LinkedList区别及使用场景_Forget_Sky的博客-CSDN博客_arraylist linkedlist</a></h3>
</blockquote>
<h3 id="arraylist_5">ArrayList 是如何扩容的？</h3>
<ul>
<li>ArrayList在调用无参构造方法时创建的是一个长度为0的空数组，当调用add()方法添加元素时，ArrayList才会触发扩容机制。</li>
<li>新容量 = 旧容量 * 1.5，所以才有ArrayList每次扩容为旧容量的1.5倍的说法。</li>
<li>addAll()方法总是选择<strong>扩容一次后的容量</strong>与<strong>旧容量加上添加的元素个数的容量</strong>中取一个<strong>最大值</strong>作为新的容量</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/qq_42453117/article/details/122099920">ArrayList的扩容机制_·wangweijun的博客-CSDN博客_arraylist 扩容机制</a>
</p>
</blockquote>
<h3 id="95-arraylist">95.请你谈一谈 ArrayList自动扩容机制的实现原理</h3>
<p>一位3 年工作经验的小伙伴面试时被问到，说请你谈一谈ArrayList 自动扩容机制的实现原理。这个问题对于稍微看过一点源码的小伙伴来说，其实非常简单。下面我给大家分享一下我对这个问题的理解。</p>
<h4 id="1">1 存储容器</h4>
<p><img alt="1671120757326-770006cb-79e8-4444-ab87-e693d63ec5e4.png" src="../img/87hgbhv296BleQFn/1671120757326-770006cb-79e8-4444-ab87-e693d63ec5e4-936168.png" /></p>
<p>ArrayList 是一个数组结构的存储容器，默认情况下，数组的长度是10。当然，我们也可以在构建 ArrayList 对象的时候，直接指定初始长度。那么，随着程序的运行，不断地往 ArrayList 中添加数据，当添加的数据达到 10 个的时候，ArrayList就没有足够的容量来存储后面添加的数据。那么，这个时候，ArrayList 会触发自动扩容机制。</p>
<h4 id="2">2 扩容原理</h4>
<p><img alt="1671120764293-693fe459-6f16-4d55-b3f1-14b3180383d9.png" src="../img/87hgbhv296BleQFn/1671120764293-693fe459-6f16-4d55-b3f1-14b3180383d9-691193.png" /></p>
<p>扩容的流程其实也很简单，首先创建一个新的数组，这个数组的长度是原来数组长度的 1.5 倍。然后，使用 Arrays.copyOf()方法把原数组中的数据拷贝到新数组中。扩容完成之后，再把当前要添加的数据加入到新的数组中，从而完成动态扩容的过程。</p>
<p>好了，以上就是我对这个问题的理解。作为一个业务程序员，虽然工作的性质是让家去写CRUD，不需要过多的去关注技术的底层实现原理。但是，在未来的职业晋升过程中，对技术的理解程度非常重要。</p>
<h3 id="105arraylistvectorlinkedlist">105.谈谈ArrayList、Vector和LinkedList 的存储性能及特性</h3>
<p>又有一位工作2 年的小伙伴面试的时候，被问到一个集合相关的问题。说请你谈谈ArrayList、Vector和LinkedList 的存储性能及特性。</p>
<p>今天呢，我给大家分享一下我对这个问题的理解。</p>
<h4 id="1_1">1、存储性能及特性</h4>
<p>关于ArrayList、Vector 和LinkedList 的存性能理及特性，我从以下3 个方面来分析：</p>
<p><img alt="1671123059693-7a546195-cabe-4935-9a96-367376db821a.png" src="../img/87hgbhv296BleQFn/1671123059693-7a546195-cabe-4935-9a96-367376db821a-488736.png" /></p>
<p>1）首先，ArrayList 和 Vector 的底层都是采用数组的来存储数据，而且都是根据索引来取数据，这样设计使得获取数据快而插入数据慢。另外，每次扩容都要移动数组中的元素，存储数据量较大的时候会影响读写性能。</p>
<p><img alt="1671123072731-999515a5-ab44-4205-8766-08a1a592a49e.png" src="../img/87hgbhv296BleQFn/1671123072731-999515a5-ab44-4205-8766-08a1a592a49e-335565.png" /></p>
<p>2）其次，由于Vector 中的方法都使用了 synchronized 修饰，因此 ，Vector 中对数据操作都是线程安全的，但性能上比ArrayList 差。</p>
<p><img alt="1671123080851-ab3a9b0f-d9cd-4e5d-8b10-5ea1583ec8e2.png" src="../img/87hgbhv296BleQFn/1671123080851-ab3a9b0f-d9cd-4e5d-8b10-5ea1583ec8e2-779399.png" /></p>
<p>3）然后，LinkedList 的底层是采用双向链表来存储数据的，也就是说将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高。LinkedList获取数据需要根据索引序号，向前或者向后遍历，但是插入数据时只需要记录本项的前后项即可，所以，LinkedList插入数据的速度更快。</p>
<p><img alt="1671123098289-4d3047b1-ea75-4c75-bdeb-9dd961501f6c.png" src="../img/87hgbhv296BleQFn/1671123098289-4d3047b1-ea75-4c75-bdeb-9dd961501f6c-921211.png" /></p>
<p>4）最后，再补充一点，Vector是Java 早期的版本中提供的容器， 属于遗留容器，官方已经不再推荐使用。但是由于 ArrayList 和 LinkedListed 都是非线程安全的，在多线程环境下，可以使用工具类Collections 的 synchronizedList() 方法，将容器转换成线程安全的容器再使用。这其实也是装饰器模式的一种应用。</p>
<h4 id="2_1">2、关于遗留容器</h4>
<p>关于Java 中的遗留容器，我最后再补充一下。除Vector 之外，还有Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器，这些容器中，Properties 类存在比较严重的设计缺陷。来看这段源码：</p>
<pre><code class="language-java">/*
Since : JDK1.0
See Also : native2ascii tool for Solaris, native2ascii tool for
Windows
Author : Arthur van Hoff, Michael McCloskey, Xueming Shen
*/
public class Properties extends Hashtable&lt;Object,Object&gt; {

}
</code></pre>
<p>Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable，并将它的两个泛型参数设置为 String 类型，但是 Java API 中的Properties 是直接继承了 Hashtable，这很明显是对继承的滥用。主要体现在以下两个方面：</p>
<p><img alt="1671123182772-21bee6b6-16f8-4300-a697-3480b9b02cdf.png" src="../img/87hgbhv296BleQFn/1671123182772-21bee6b6-16f8-4300-a697-3480b9b02cdf-388287.png" /></p>
<p>1）首先，根据合成复用原则，这里Properties 和Hashtable的代码复用关系应该是 Has-A 关系，而不是 Is-A 关系。</p>
<p>2）另一方面，这两个容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关联）或Use-A 关系（依赖）。</p>
<p>既然都讲到这里了，最后再扩展一下Stack 类在设计上也存在Properties同样的缺陷。来看这样一段源码：</p>
<p><img alt="1671123219008-93f76489-5f70-499f-a2f0-dbe921de4d08.png" src="../img/87hgbhv296BleQFn/1671123219008-93f76489-5f70-499f-a2f0-dbe921de4d08-201382.png" /></p>
<pre><code class="language-java">/*
Since : JDK1.0
Author : Jonathan Payne
*/
public class Stack&lt;E&gt; extends Vector&lt;E&gt; {

}
</code></pre>
<p>在JDK的util包中，我们发现Stack类也是继承了 Vector，这个设计也是不太合理的。</p>
<p>好了，以上就是我对ArrayList、Vector和LinkedList的理解。</p>
<h3 id="vector">Vector是一个线程安全类吗？</h3>
<p>很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>
<blockquote>
<p>更新: 2023-07-14 01:27:32<br />
原文: <a href="https://www.yuque.com/joyo/interview/cl5pdslk000fhbc4">https://www.yuque.com/joyo/interview/cl5pdslk000fhbc4</a></p>
</blockquote>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>