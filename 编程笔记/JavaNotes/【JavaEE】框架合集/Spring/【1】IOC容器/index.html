
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="褚成志">
      
      
        <link rel="canonical" href="http://blog.chucz.asia/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/JavaNotes/%E3%80%90JavaEE%E3%80%91%E6%A1%86%E6%9E%B6%E5%90%88%E9%9B%86/Spring/%E3%80%901%E3%80%91IOC%E5%AE%B9%E5%99%A8/">
      
      
      
      
      <link rel="icon" href="../../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>【1】 IOC 容器 - 褚成志的技术博客</title>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../../../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1-ioc" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../../../.." title="褚成志的技术博客" class="md-header__button md-logo" aria-label="褚成志的技术博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            褚成志的技术博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              【1】 IOC 容器
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../.." title="褚成志的技术博客" class="md-nav__button md-logo" aria-label="褚成志的技术博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    褚成志的技术博客
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    首页
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="1-ioc">【1】 IOC 容器</h1>
<h1 id="ioc">IOC 的概念</h1>
<p><strong>IOC 控制反转</strong>，是面向对象编程中的一种设计原则，可以用来降低计算机代码之间的耦合度。</p>
<ol>
<li>控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理</li>
<li>使用 IOC 目的，为了耦合度降低</li>
</ol>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。</p>
<p>这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 </p>
<p>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。</p>
<p>如果利用 IoC 的话，只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<h1 id="ioc_1">IOC 的引入</h1>
<p><strong>xml 解析、工厂模式、反射</strong></p>
<p>原始方法，创建对象，调用方法。</p>
<p>缺点是耦合度太高了。</p>
<p><img alt="1672727279608-1f636bd7-65d3-4eac-b7c5-44c44ec7a06d.png" src="../img/WFqtO4t1qkbx9XCK/1672727279608-1f636bd7-65d3-4eac-b7c5-44c44ec7a06d-213048.png" /></p>
<p><strong>工厂模式</strong></p>
<p><img alt="1672727462736-fa76d37b-74e1-43f1-989d-b0a28f7cf091.png" src="../img/WFqtO4t1qkbx9XCK/1672727462736-fa76d37b-74e1-43f1-989d-b0a28f7cf091-328655.png" /></p>
<p><strong>IOC 过程</strong></p>
<p>首先是创建xml文件来进行创建的对象的配置</p>
<p>然后使用工厂类对xml进行解析，</p>
<p>解析后通过反射来创建对象，classValue 就是 xml 里面的 com.atguigu.UserDao。</p>
<p>最后返回这个类</p>
<p><img alt="1672727910355-c68b9c41-593c-4446-8b14-1ef54f774329.png" src="../img/WFqtO4t1qkbx9XCK/1672727910355-c68b9c41-593c-4446-8b14-1ef54f774329-827430.png" /></p>
<p>这个时候只需要修改 xml 配置文件里面的对象路径就可以了。</p>
<h1 id="ioc-beanfactory">IOC 接口（BeanFactory）</h1>
<ol>
<li>IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂</li>
<li>Spring 里面提供了 IOC 容器实现的两种方式（两个接口）。<ol>
<li>BeanFactory：IOC 容器最基本的实现方式，是 Spring 内部的使用的接口，不提供开发人员使用【特点是，加载配置文件的时候不会创建对象，在获取（使用）对象的时候才会创建对象。】</li>
<li>ApplicationContext：BeanFactory 接口的子接口，提供更大更强大的功能，<strong>一般由开发人员使用</strong>【特点是，加载配置文件的时候就会在配置文件对象进行创建。】</li>
</ol>
</li>
<li>ApplicationContext 接口有实现类<ol>
<li>FileSystemXmlApplicationContext：写文件的全路径（绝对路径）</li>
<li>ClassPathXmlApplicationContext：写类的路径【通常使用】</li>
</ol>
</li>
<li>BeanFactory 下面有个子接口 ConfigurableApplictionContext 拓展使用。</li>
</ol>
<h1 id="xml-bean">XML Bean 管理</h1>
<h2 id="bean">什么是 Bean 管理？</h2>
<p>Bean 管理指的是两个操作。</p>
<p>Bean有两个操作：</p>
<ol>
<li>Spring 创建对象</li>
<li>Spring 注入属性</li>
</ol>
<p>Bean 管理操作有两种方式：</p>
<ol>
<li>基于 XML 配置文件方式实现</li>
<li>基于注解方式实现</li>
</ol>
<h2 id="xml">基于 xml 配置文件方式实现</h2>
<ol>
<li><strong>基于 XML 方式创建对象</strong></li>
</ol>
<pre><code class="language-java">&lt;bean id=&quot;user&quot; class=&quot;com.javastudy.spring5&quot;&gt; &lt;/bean&gt;
</code></pre>
<p>在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建</p>
<p>在 bean 标签有很多属性：</p>
<ul>
<li>id 属性：唯一的标识</li>
<li>class 属性：创建的类的全路径（包类的路径）</li>
<li>name 属性：可以用特殊符号，功能类似 id 属性</li>
</ul>
<p>创建对象时候，默认也是执行无参数构造方法完成对象创建。</p>
<ol>
<li><strong>基于 XML 方式注入属性</strong></li>
</ol>
<p>DI：依赖注入，就是注入属性（DI 是 IOC 的特殊实现）。</p>
<p>依赖注入，前提必须有 IOC 的环境，Spring 管理这个类的时候将类的依赖的属性注入（设置）进来。就是 spring在帮我们创建这个类的实例当中，发现这个类中有一个属性，帮我们把这个属性设置进来。</p>
<ol>
<li>第一种注入方式，使用 set 方法进行注入</li>
<li>第二种注入方式，使用参数构造进行注入</li>
</ol>
<h3 id="set">set 方法注入</h3>
<pre><code class="language-java">package com.javastudy.spring5;
public class Book{
    //创建属性
    private String bname;
    private String bauthor;
    //set 方法注入
    public void setBname(String bname){
        this.bname= bname;
    }
    public void setBauthor(String bauthor){
        this.bauthor= bauthor;
    }
    //有参数构造注入
    public Book(String bname){
        this.bname = bnmame;
    }
}
</code></pre>
<p>传统方式是使用 new 创建对象，然后调用 set 方法。</p>
<p>在 spring 配置文件配置对象创建，配置属性注入。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;com.javastudy.spring5&quot;&gt;
  &lt;!--使用 property 完成属性注入
    name：类里面属性名称
    value：向属性注入的值
    --&gt;
    &lt;property name=&quot;bname&quot; value=&quot;活着&quot;&gt;&lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<pre><code class="language-java">package com.javastudy.spring5;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class TestIOC{
    public static void main(String[] args){
        //1. 初始化 spring 容器，加载配置文件
        ApplicationContext applicationContext = new ClassPathXmlApplication(&quot;bean1.xml&quot;);
        //2. 加载配置文件时候，对 Bean 进行实例化 
        Book book = applicationContext.getBean(&quot;book&quot;,Book.class);
        System.out.println(book);
        book.testDemo();
    }
}
</code></pre>
<h3 id="_1">有参构造进行注入</h3>
<ol>
<li>创建类，定义属性</li>
</ol>
<pre><code class="language-java">package com.javastudy.spring5;
public class Orders{
    //创建属性
    private Stirng oname;
    private String address;
    public Orders(String oname, String address){
        this.oname = oname;
        this.address = address;
    }
}
</code></pre>
<ol>
<li>在 spring 配置文件中进行配置</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;com.javastudy.spring5&quot;&gt;
    &lt;!--使用 property 完成属性注入
    name：类里面属性名称
    value：向属性注入的值
    &lt;property name=&quot;bname&quot; value=&quot;活着&quot;&gt;&lt;/property&gt;
     --&gt;
    &lt;bean id=&quot;orders&quot; class=&quot;com.javastudy.spring5&quot;&gt;
      &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt;
      &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ol>
<li>测试</li>
</ol>
<pre><code class="language-java">package com.javastudy.spring5.testDemo;
@Test
public void testOrders(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
    Orders orders = context.getBean(&quot;orders&quot;,Orders.class);
    System.out.println(orders);
    orders.testDemo();
}
</code></pre>
<h3 id="set-p">set 注入的写法简化 - p名称空间注入（了解）</h3>
<ol>
<li>使用 p 名称空间注入，可以简化基于 xml 配置方式<ol>
<li>添加 p 名称空间在配置文件中</li>
<li>进行属性注入，在 bean 标签里面进行操作</li>
</ol>
</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;bean id=&quot;book&quot; class=&quot;com.javastudy.spring5.Book&quot; p:bname=&quot;活着&quot; p.bauthor=&quot;余华&quot;&gt;
  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="xml_1">XML 其它类型的注入其他类型属性</h3>
<p>前面的类型都是String，现在看看其他的类型怎么注入。</p>
<p>这里有个字面量的概念，大致意思就是字面上就能看到量的变量。</p>
<ul>
<li>NULL 值</li>
<li>属性值包含特殊符号</li>
</ul>
<h4 id="null">Null</h4>
<pre><code class="language-java">public class Book{
    private String bname;
    private String bauthor;
    private String address;
    public void setBname(String bname){this.bname = bname;}
    public void setBauthor(String bauthor){this.bauthor = bauthor;}
    public void setAddress(String address){this.address = address;}
}
public void testDemo(){
    System.out.println(bname+&quot;::&quot;+bauthor+&quot;::&quot;+address);
}


</code></pre>
<p>如果是正常有值进行注入的话：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;com.javastudy.spring5&quot;&gt;
  &lt;!--使用 property 完成属性注入
    name：类里面属性名称
    value：向属性注入的值
    --&gt;
    &lt;property name=&quot;bname&quot; value=&quot;活着&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;bauthor&quot; value=&quot;余华&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;address&quot; value=&quot;北京&quot;&gt;&lt;/property&gt;

  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>但是如果这个地址是一个空值（NULL）那应该怎么办呢？</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;com.javastudy.spring5&quot;&gt;
  &lt;!--使用 property 完成属性注入
    name：类里面属性名称
    value：向属性注入的值
    --&gt;
    &lt;property name=&quot;bname&quot; value=&quot;活着&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;bauthor&quot; value=&quot;余华&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;address&quot;&gt;
      &lt;/null&gt;
    &lt;/property&gt;

  &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>如上，在 property 里面写一个<code>&lt;/null&gt;</code>标签。</p>
<h4 id="_2">特殊符号</h4>
<p>下面这种写法是错误的。&lt;&lt; 是特殊符号。</p>
<pre><code class="language-xml">&lt;property name=&quot;bname&quot; value=&quot;&lt;&lt;活着&gt;&gt;&quot;&gt;&lt;/property&gt;
</code></pre>
<p>我们需要把它进行转义。</p>
<pre><code class="language-xml">&lt;property name=&quot;bname&quot;&gt;
  &lt;value&gt;&lt;![CDATA[&lt;活着&gt;&gt;]]&gt;&lt;/value&gt;
&lt;/property&gt;
</code></pre>
<h3 id="-bean">注入属性 - 外部 Bean</h3>
<p>什么是外部 Bean？</p>
<ol>
<li>创建两个类，service 类和 dao 类</li>
<li>在 service 调用 dao 里面的方法</li>
</ol>
<pre><code class="language-java">package com.javastudy.spring5.service;
public class UserService{
    public void add(){
        System.out.println(&quot;service add...&quot;);
        //普通方式是在service 里面创建个对象
        UserDao dao = new UserDaoImpl();
        dao.update();
    }
}
</code></pre>
<pre><code class="language-java">package com.javastudy.spring5.dao;
public interface UserDao{
    public void update();
}
</code></pre>
<pre><code class="language-java">package com.javastudy.spring5.dao;
public class UserDaoImpl implements UserDao{
    @Override
    public void update(){
        System.out.println(&quot;dao update ...&quot;);
    }
}
</code></pre>
<ol>
<li>在 spring 的配置文件中进行配置</li>
</ol>
<p>这个时候我们想要注入 UserDao 这个对象类型。</p>
<pre><code class="language-java">package com.javastudy.spring5.service;
import com.javastudy.spring5.dao.UserDao;

public class UserService{
    private UserDao userDao;
    public void setUserDao(UserDao userDao){
        this.userDao = userDao;
    }
    public void add(){
        System.out.println(&quot;service add...&quot;);
        userDao.update();
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;!--1 service 和 dao 对象创建 --&gt;
  &lt;bean id=&quot;userService&quot; class=&quot;com.javastudy.spring5.UserService&quot;&gt; 
  &lt;!--注入userDao对象
      name属性值：类里面属性名称
      ref属性，创建userDao对象bean标签id值
    --&gt;
    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
  &lt;/bean&gt;
  &lt;bean id=&quot;userDao&quot; class=&quot;com.javastudy.spring5.UserDaoImpl&quot;&gt; &lt;/bean&gt;


&lt;/beans&gt;
</code></pre>
<p>第 8 行 ，要在class里面写上类的路径，但是由于 interface 没有方法的实现，所以我们放 UserDaoImpl。</p>
<p><bean id="userDao" class="com.javastudy.spring5.UserDaoImpl"> </bean></p>
<pre><code class="language-java">public class TestBean{
    public void testAdd(){
        //1.加载spring配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;);
        //2.获取配置创建的对象
        UserService userService = context.getBean(&quot;userService&quot;,UserService.class);
        userService.add();
    }
}
</code></pre>
<p>执行结果：</p>
<pre><code class="language-shell">service add...
dao update ...
</code></pre>
<h3 id="-bean_1">注入属性 - 内部 bean和级联赋值</h3>
<h4 id="bean_1">内部 bean</h4>
<ol>
<li>一对多的关系：部门和员工，一个部门有多个员工，一个员工只有一个部门；</li>
<li>在实体类来表示一对多关系（一个表就是一个类），员工所属的部门属性，用对象类型来表示；</li>
</ol>
<pre><code class="language-java">package com.javastudy.spring5.bean;

public class Dept{
    private String dname;
    public void setDname(String dname){
        this.dname = dname;
    }
}
</code></pre>
<pre><code class="language-java">package com.javastduy.spring5.bean;
public class Emp{
    private String ename;
    private String gender;
    //员工属于某一个部门，用 Dept 对象来表示
    private Dept dept;
    public void setDept(Dept dept){
        this.dept = dept;
    }
    public void setEname(String ename){
        this.ename = ename;
    }
    public void setGender(String gender){
        this.gender = gender;
    }
}
</code></pre>
<p>这样我们就建立了两个类，这两个类之间还没有建立关系。</p>
<p>怎么表示多个员工？</p>
<ol>
<li>在 Spring 配置文件中进行相关配置</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;!--内部bean --&gt;
    &lt;bean id=&quot;emp&quot; class=&quot;com.javastudy.spring5.bean.Emp&quot;&gt;
    &lt;!--设置两个普通属性--&gt;
    &lt;property name=&quot;dept&quot;&gt;
      &lt;bean id=&quot;dept&quot; class=&quot;com.javastudy.spring5.bean.Dept&quot;&gt;
        &lt;property name=&quot;dname&quot; value=&quot;软件研发部&quot;&gt;&lt;/property&gt;
      &lt;/bean&gt;
      &lt;/property&gt;
&lt;/beans&gt;
</code></pre>
<p>在一个 bean 里面嵌套了另外一个 bean，这就叫做内部 bean。</p>
<h4 id="_3">级联赋值</h4>
<p>修改 xml 文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;!--内部bean --&gt;
    &lt;bean id=&quot;emp&quot; class=&quot;com.javastudy.spring5.bean.Emp&quot;&gt;
    &lt;!--设置两个普通属性--&gt;
    &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;gender&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt;
    &lt;!--级联赋值--&gt;
    &lt;property name=&quot;dept&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
      &lt;bean id=&quot;dept&quot; class=&quot;com.javastudy.spring5.bean.Dept&quot;&gt;
        &lt;property name=&quot;dname&quot; value=&quot;软件研发部&quot;&gt;&lt;/property&gt;
      &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="_4">注入集合属性</h3>
<ol>
<li>注入数组类型的属性</li>
<li>注入list集合类型的属性</li>
<li>注入Map集合类型的属性</li>
</ol>
<h4 id="_5">注入数组类型的属性</h4>
<pre><code class="language-java">import java.util.List;
import java.util.Map;
import java.util.Set;
public class Stu{
    //1 数组类型属性
    private String[] courses;
    //2 list集合类型属性
    private List&lt;String&gt; list;
    //3 map集合类型属性
    private Map&lt;String,String&gt; maps;
    //4 set集合类型属性
    private Map&lt;String,String&gt; sets;
    public void setSets(Set&lt;String&gt; sets){
        this.set = set;
    }
    public void setCourses(String[] courses){
        this.courses = courses;
    }
    public void setList(List&lt;String&gt; list){
        this.list = list;
    }
    public void setMap(Map&lt;String,String&gt; maps){
        this.maps = maps;
    }
}
</code></pre>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

  &lt;!--1 集合类型属性注入 --&gt;
  &lt;property name=&quot;courses&quot;&gt;
    &lt;array&gt;
      &lt;value&gt;java课程&lt;/value&gt;
      &lt;value&gt;数据库课程&lt;/value&gt;
    &lt;/array&gt;
  &lt;/property&gt;

  &lt;!--2 list类型属性注入 --&gt;
  &lt;property name=&quot;list&quot;&gt;
    &lt;list&gt;
      &lt;value&gt;张三&lt;/value&gt;
      &lt;value&gt;法外狂徒&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;

  &lt;!--3 map类型属性注入 --&gt;
  &lt;property name=&quot;maps&quot;&gt;
    &lt;map&gt;
      &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt;
      &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt;
    &lt;/map&gt;    
  &lt;/property&gt;

  &lt;!--4 sets类型属性注入 --&gt;
  &lt;property name=&quot;sets&quot;&gt;
    &lt;sets&gt;
      &lt;value&gt;Mysql&lt;/value&gt;
      &lt;value&gt;Redis&lt;/value&gt;
    &lt;/sets&gt;    
  &lt;/property&gt;
&lt;/beans&gt;
</code></pre>
<h3 id="xml_2">XML 自动装配（少用）</h3>
<p>自动装配就是根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入。</p>
<p>还是使用部门和员工的例子：</p>
<pre><code class="language-java">package com.javastudy.spring5.autowrie;
public class Emp{
    private Dept dept;
    public void setDept(Dept dept){
        this.dept = dept;
    }

    @Override
    public String toString(){
        return &quot;Emp{&quot;+
            &quot;dept=&quot; + dept +
            '}';
    }
    public void test(){
        System.out.println(dept);
    }
}
</code></pre>
<pre><code class="language-java">package com.javastudy.spring5.autowrie;
public class Dept{
    private String toString{
        return &quot;Dept{}&quot;;
    }
}
</code></pre>
<p>普通方式可以使用外部 bean 的方式进行注入。那么自动装配的 bean 是怎么实现的呢？</p>
<p>Bean 标签中有一个属性叫做 autowrie 可以实现自动装配。</p>
<ul>
<li>byName 根据属性名称注入，注入值 bean 的 id 值和类属性名称一样</li>
<li>byType 根据属性类型注入</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;emp&quot; class=&quot;com.javastudy.spring5.autowire.Emp&quot; autowire=&quot;byName&quot;&gt;
&lt;/bean&gt;
&lt;bean id=&quot;dept &quot; class=&quot;com.javastudy.spring5.autowire.Emp&quot;&gt;
&lt;/bean&gt;


</code></pre>
<p><img alt="1673334720996-63cdd3da-9457-405e-8365-91358928ec42.png" src="../img/WFqtO4t1qkbx9XCK/1673334720996-63cdd3da-9457-405e-8365-91358928ec42-798083.png" /></p>
<h2 id="factorybean">FactoryBean 的创建</h2>
<p>Spring 有两种 Bean，一种是普通的 Bean，另一种是 FactoryBean。</p>
<p>普通 Bean：在 Spring 里面， 配置文件中定义的类型就是返回的类型。</p>
<p>工厂 Bean：在配置文件定义 bean 类型可以和返回类型不一样。</p>
<p>创建工厂 Bean 有以下两步：</p>
<ul>
<li>第一步，创建类，让这个类作为工厂 bean，实现接口 FactoryBean。</li>
<li>第二步，实现接口里面的方法，在实现的方法中定义返回的 bean 类型。</li>
</ul>
<p><strong>第一步：创建类</strong></p>
<pre><code class="language-java">package com.javastudy.spring5.factorybean;
public class MyBean{

}
</code></pre>
<p>把对象通过配置文件创建出来：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
  &lt;bean id=&quot;myBean&quot; class=&quot;com.javastudy.spring5.factorybean.MyBean&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<p>输出一下这个 Bean</p>
<pre><code class="language-java">public void test3(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;);
    //返回类型也是 MyBean,普通 Bean
    MyBean myBean = context.getBean(&quot;myBean&quot;,MyBean.class);
    System.out.println(myBean);
}
</code></pre>
<p><strong>第二步：实现接口里面的方法</strong></p>
<p>想要变成 FactoryBean 需要让 MyBean 实现一个 FactoryBean 接口：</p>
<pre><code class="language-java">package com.javastudy.spring5.factorybean;
public class MyBean implements FactoryBean&lt;Course&gt;{
    //定义返回 bean
    @Override
    public Course getObject() throws Exception{
        Course course = new Course();
        course.setCname(&quot;abc&quot;);
        return course;
    }

}
</code></pre>
<p>这个时候这个测试的第 4 行里面应该进行修改。</p>
<pre><code class="language-java">public void test3(){
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;);
    //返回类型也是 MyBean,普通 Bean
    MyBean myBean = context.getBean(&quot;myBean&quot;,Course.class);
    System.out.println(myBean);
}
</code></pre>
<h1 id="bean_2">Bean 的作用域</h1>
<p>什么是 Bean 的作用域？</p>
<p>有两个知识点需要了解：</p>
<ol>
<li>在 Spring 里面，设置创建 bean 实例是单实例还是多实例</li>
<li>在 Spring 里面，默认情况下，bean 是单实例对象</li>
</ol>
<p><img alt="单实例对象，地址相同" src="../img/WFqtO4t1qkbx9XCK/1673319562610-ff4a8106-f023-40c8-a913-4b23387f1c0a-927626.png" /></p>
<p>想要设置单实例还是多实例，在 Spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例。</p>
<p>scope 属性值有两个值：</p>
<ul>
<li>默认值，singleton，表示是单实例对象</li>
<li>prototype 表示是多实例对象</li>
</ul>
<pre><code class="language-xml">&lt;bean id=&quot;book&quot; class=&quot;com.javastudy.spring5.collectiontype.Book&quot; scope=&quot;singleton&quot;&gt;
  &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>singleton 和 prototype 区别：</p>
<ul>
<li>singleton 单实例，prototype 多实例</li>
<li>设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象；设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象</li>
</ul>
<h1 id="bean_3">Bean 生命周期（重点）</h1>
<p>参考文章：</p>
<p><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">Spring Bean的生命周期（非常详细） - Chandler Qian - 博客园</a></p>
<p>生命周期就是从对象创建到对象销毁的过程。</p>
<p>在 Spring 的 IOC 容器中可以管理 bean 的生命周期，Spring 允许在 bean 生命周期内特定的时间点执行指定的任务。</p>
<p>生命周期有以下：</p>
<ol>
<li>通过构造器创建 bean 实例（无参数构造）</li>
<li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li>
<li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li>
<li>bean 可以使用了（对象获取到了）</li>
<li>当容器关闭时候，调用 bean 的<strong>销毁方法</strong>（需要进行配置销毁的方法）</li>
</ol>
<p><strong>这里需要引入 Bean 后置处理器的概念：</strong></p>
<p>什么是 bean 的后置处理器？bean 后置处理器允许在调用初始化方法前后对 bean 进行额外的处理。</p>
<p>加入后置处理器之后生命周期变为 7 步：</p>
<ol>
<li>通过构造器创建 bean 实例（无参数构造）</li>
<li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li>
<li><strong>把 bean 实例传递 bean 后置处理器的方法</strong></li>
<li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li>
<li><strong>把 bean 实例传递 bean 后置处理器的方法</strong></li>
<li>bean 可以使用了（对象获取到了）</li>
<li>当容器关闭时候，调用 bean 的<strong>销毁方法</strong>（需要进行配置销毁的方法）</li>
</ol>
<h1 id="bean_4">注解 Bean 管理</h1>
<h2 id="_6">什么是注解</h2>
<ol>
<li>注解是代码的特殊标记。格式：@注解名称（属性名称=属性值，属性名称=属性值...）</li>
<li>使用注解，注解作用在类上面，方法上面，属性上面</li>
<li>使用注解的目的：简化 xml 配置</li>
</ol>
<h2 id="_7">常见注解及开发流程</h2>
<p>@Component： 游戏中普通的注解</p>
<p>@Service ：业务逻辑层以及Service层</p>
<p>@Controller： 外部层</p>
<p>@Repository ：dao层即持久层</p>
<p>功能是一样的，都可以用来创建对象，只不过把每个对象用在不同地方，以便查看。</p>
<h3 id="_8">对象的创建</h3>
<p><strong>第一步：</strong>引入 AOP 的依赖</p>
<p><img alt="aop 依赖被引入" src="../img/WFqtO4t1qkbx9XCK/1673336835458-720bd023-619b-429a-b0c3-c36667406f61-587500.png" /></p>
<p><strong>第二步</strong>：开启组件扫描</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
  xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans

  http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
  http://www.springframework.org/schema/context
  http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;

  &lt;!--开启组件扫描
  1.如果扫描多个包，多个包使用逗号隔开
  2. 扫描包上层目录
  --&gt;
  &lt;context:component-scan base-package=&quot;com.javastudy&quot;&gt;&lt;/context:component-scan&gt;  
&lt;/beans&gt;
</code></pre>
<p>base-package如果定义多个包，可以加全路径，分别用逗号隔开 或者 是放置上层目录。</p>
<p><strong>第三步：</strong>创建类，在类上面添加创建对象注解。</p>
<pre><code class="language-java">package com.javastudy.spring5.service;
import org.springframework.sterotype.Component;
//在注解里面value属性值可以省略不写
//默认值是类名称，首字母小写
@Component(value = &quot;userService&quot;) //&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;
//@Repository 也可以实现一样的效果
public class UserService{
    public void add(){
        System.out.println(&quot;service add...&quot;);
    }
}

</code></pre>
<pre><code class="language-java">import org.springframework.context.support.ClassPathXmlApplicationContext;
public class TestSpring5Demo1{
    @Test
    public void testService(){
        ApplicationContext context = new ClassXmlApplicationContext(&quot;bean1.xml&quot;);
        UserService userService = context.getBean(&quot;userService&quot;,UserService.class);
        System.out.println(userService);
        userService.add();
    }
}
</code></pre>
<p><strong>第四步：</strong>开启组件扫描细节配置。</p>
<p>如果引入的包中不加说明，默认会被所有包都扫描了。</p>
<p>所以我们可以加一些说明，过滤或者添加说明只扫描一些包。</p>
<p>自定义一个过滤，定义扫描的注解类。</p>
<ul>
<li>use-default-filters="false" 表示现在不使用默认 filter，自己配置 filter</li>
<li>context:include-filter，设置扫描哪些内容</li>
<li>type 只扫描这种注解类</li>
<li>expression 表示扫描的为该注解类</li>
</ul>
<pre><code class="language-xml">&lt;!--示例 1
--&gt;
&lt;context:component-scan base-package=&quot;com.javastudy&quot; use-defaultfilters=&quot;false&quot;&gt;
  &lt;context:include-filter type=&quot;annotation&quot;
    expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;!--代表只扫描Controller注解的类--&gt;
&lt;/context:component-scan&gt;
</code></pre>
<p>不定义一个过滤，扫面的所有内容，但可设置内容不扫描。</p>
<p>context:exclude-filter： 设置哪些内容不进行扫描。</p>
<pre><code class="language-xml">&lt;!--示例 2
--&gt;
&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;
 &lt;context:exclude-filter type=&quot;annotation&quot;
expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;!--表示Controller注解的类之外一切都进行扫描--&gt;
&lt;/context:component-scan&gt;
</code></pre>
<p><strong>第五步：基于注解方式实现属性注入</strong></p>
<ol>
<li><strong>把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解；</strong></li>
<li><strong>在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解。（实现属性注入）</strong></li>
</ol>
<p>定义两个类，一个接口实现类，一个类写函数</p>
<p>接口实现类：</p>
<pre><code class="language-java">@Repository(value = &quot;userDaoImpl1&quot;)
public class UserDaoImpl implements UserDao {
    @Override
    public void add() {
        System.out.println(&quot;dao add.....&quot;);
    }
}
</code></pre>
<p><code>@Autowired</code>：根据属性类型自动装配</p>
<pre><code class="language-java">@Autowired  //根据类型进行注入
private UserDao userDao;
</code></pre>
<p><code>@Qualifier(value=" ")</code>：根据属性名称自动注入</p>
<pre><code class="language-java">@Autowired  //根据类型进行注入
@Qualifier(value = &quot;userDaoImpl1&quot;) //根据名称进行注入
private UserDao userDao;
</code></pre>
<p><code>@Resource</code>：可根据属性类型或者名称注入</p>
<pre><code class="language-java">@Resource(name = &quot;userDaoImpl1&quot;)  //根据名称进行注入
private UserDao userDao;
</code></pre>
<p><code>@Value：</code>注入普通类型的注入</p>
<p>注解不是对象类型的定义，可以是字符串等其他</p>
<pre><code class="language-java">@Value(value = &quot;abc&quot;)
private String name;
</code></pre>
<h2 id="_9"><font style="color:rgb(0, 0, 0);">完全注解开发</font></h2>
<p>完全注解开发指的是，不使用 xml 配置文件。完全地使用注解开发。</p>
<p>主要是引用两个注解：</p>
<p><code>@Configuration</code> 作为配置类的提示</p>
<p><code>@ComponentScan</code> 扫描配置类的注解</p>
<p>创建配置类，替代 xml 配置文件。</p>
<pre><code class="language-java">@Configuration  //作为配置类，替代xml配置文件
@ComponentScan(basePackages = {&quot;com.atguigu&quot;})
public class SpringConfig {

}

</code></pre>
<p>测试类和之前不一样，</p>
<p>之前是加载配置文件 xml，</p>
<p>现在是 new 一个对象，对象为注解的配置类，即加载这个配置类 AnnotationConfigApplicationContext。</p>
<pre><code class="language-java">@Test
public void testService2() {
    //加载配置类
    ApplicationContext context
            = new AnnotationConfigApplicationContext(SpringConfig.class);
    UserService userService = context.getBean(&quot;userService&quot;, UserService.class);
    System.out.println(userService);
    userService.add();
}

</code></pre>
<blockquote>
<p>更新: 2024-03-29 22:55:09<br />
原文: <a href="https://www.yuque.com/xiaoshan_wgo/codingnotes/uwkbbnekgkzz4tgg">https://www.yuque.com/xiaoshan_wgo/codingnotes/uwkbbnekgkzz4tgg</a></p>
</blockquote>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../../../..", "features": [], "search": "../../../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>