
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="褚成志">
      
      
        <link rel="canonical" href="http://blog.chucz.asia/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/GoNotes/%E3%80%90Go%E3%80%91%E7%AC%94_%E9%9D%A2%E8%AF%95/%E4%BA%8C%E6%89%8B%E8%B5%84%E6%96%99%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/">
      
      
      
      
      <link rel="icon" href="../../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.23">
    
    
      
        <title>极客时间大厂面试题 - 褚成志的技术博客</title>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../../../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../../../.." title="褚成志的技术博客" class="md-header__button md-logo" aria-label="褚成志的技术博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            褚成志的技术博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              极客时间大厂面试题
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../.." title="褚成志的技术博客" class="md-nav__button md-logo" aria-label="褚成志的技术博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    褚成志的技术博客
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    首页
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="_1">极客时间大厂面试题<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h1 id="golang">Golang 基础<a class="headerlink" href="#golang" title="Permanent link">&para;</a></h1>
<h2 id="1-go"><font style="color:rgb(0,0,0);">1、与其他语言相比，使用 Go 有什么好处？ </font><a class="headerlink" href="#1-go" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">Go 代码的设计是务实的。每个功能和语法决策都旨在让程序员的生活更轻松。Golang 针对并发进行了优化，并且在规模上运行良好。由于单一的标准代码格式，Golang 通常被认为比其他语言更具可读性。 自动垃圾收集明显比 Java 或 Python 更有效，因为它与程序同时执行。 </font></p>
<h2 id="2golang"><font style="color:rgb(0,0,0);">2、Golang 使用什么数据类型？ </font><a class="headerlink" href="#2golang" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">Golang 使用以下类型：</font></p>
<ul>
<li><font style="color:rgb(0,0,0);">Method </font></li>
<li><font style="color:rgb(0,0,0);">Boolean </font></li>
<li><font style="color:rgb(0,0,0);">Numeric </font></li>
<li><font style="color:rgb(0,0,0);">String </font></li>
<li><font style="color:rgb(0,0,0);">Array </font></li>
<li><font style="color:rgb(0,0,0);">Slice </font></li>
<li><font style="color:rgb(0,0,0);">Struct </font></li>
<li><font style="color:rgb(0,0,0);">Pointer </font></li>
<li><font style="color:rgb(0,0,0);">Function </font></li>
<li><font style="color:rgb(0,0,0);">Interface </font></li>
<li><font style="color:rgb(0,0,0);">Map </font></li>
<li><font style="color:rgb(0,0,0);">Channel9 </font></li>
</ul>
<h2 id="3go"><font style="color:rgb(0,0,0);">3、Go 程序中的包是什么？ </font><a class="headerlink" href="#3go" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">包 (pkg) 是 Go 工作区中包含 Go 源文件或其他包的目录。源文件中的每个函数、变量和类型都存储在链接包中。每个 Go 源文件都属于一个包，该包在文件顶部使用以下命令声明： </font></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;package &lt;packagename&gt; &lt;/font&gt;</code></p>
<p><font style="color:rgb(0,0,0);">您可以使用以下方法导入和导出包以重用导出的函数或类型： </font></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;import &lt;packagename&gt; &lt;/font&gt;</code></p>
<p><font style="color:rgb(0,0,0);">Golang 的标准包是 fmt，其中包含格式化和打印功能，如 Println(). </font></p>
<h2 id="4go"><font style="color:rgb(0,0,0);">4、Go 支持什么形式的类型转换？将整数转换为浮点数。 </font><a class="headerlink" href="#4go" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">Go 支持显式类型转换以满足其严格的类型要求。 </font></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;i := 55 //int &lt;/font&gt;</code></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;j := 67.8 //float64 &lt;/font&gt;</code></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;sum := i + int(j) //j is converted to int &lt;/font&gt;</code></p>
<h2 id="5-goroutine"><font style="color:rgb(0,0,0);">5、什么是 Goroutine？你如何停止它？ </font><a class="headerlink" href="#5-goroutine" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">一个 Goroutine 是一个函数或方法执行同时旁边其他任何够程采用了特殊的Goroutine 线程。Goroutine 线程比标准线程更轻量级，大多数 Golang 程序同时使用数千个 g、Goroutine。10要创建 Goroutine，请 go 在函数声明之前添加关键字。</font></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;go f(x, y, z) &lt;/font&gt;</code></p>
<p><font style="color:rgb(0,0,0);">您可以通过向 Goroutine 发送一个信号通道来停止它。Goroutines 只能在被告知检查时响应信号，因此您需要在逻辑位置（例如 for 循环顶部）包含检查。 </font></p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span><span class="w"> </span>
<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="nx">quit</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="kd">func</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="k">select</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">                </span><span class="k">case</span><span class="w"> </span><span class="o">&lt;-</span><span class="nx">quit</span><span class="p">:</span><span class="w"> </span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span>
<span class="w">                </span><span class="k">default</span><span class="p">:</span>
<span class="w">                 </span><span class="c1">// … </span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}()</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// … </span>
<span class="w">    </span><span class="nx">quit</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>
<h2 id="6"><font style="color:rgb(0,0,0);">6、 如何在运行时检查变量类型？ </font><a class="headerlink" href="#6" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">类型开关是在运行时检查变量类型的最佳方式。类型开关按类型而不是值来评估变量。每个 Switch 至少包含一个 case，用作条件语句，和一个defaultcase，如果没有一个 case 为真，则执行。 </font></p>
<h2 id="7go"><font style="color:rgb(0,0,0);">7、Go 两个接口之间可以存在什么关系？ </font><a class="headerlink" href="#7go" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">如果两个接口有相同的方法列表，那么他们就是等价的，可以相互赋值。如果接口 A 的方法列表是接口 B 的方法列表的自己，那么接口 B 可以赋值给接口A。接口查询是否成功，要在运行期才能够确定。 </font></p>
<h2 id="8go"><font style="color:rgb(0,0,0);">8、Go 当中同步锁有什么特点？作用是什么 </font><a class="headerlink" href="#8go" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">当一个 Goroutine（协程）获得了 Mutex 后，其他 Gorouline（协程）就只能乖乖的等待，除非该 gorouline 释放了该 MutexRWMutex 在 读锁 占用的情况下，会阻止写，但不阻止读 RWMutex 在 写锁占用情况下，会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占同步锁的作用是保证资源在使用时的独有性，不会因为并发而导致数据错乱，保证系统的稳定性。</font></p>
<h2 id="9go-channel"><font style="color:rgb(0,0,0);">9、Go 语言当中 Channel（通道）有什么特点，需要注意什么？ </font><a class="headerlink" href="#9go-channel" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">如果给一个 nil 的 channel 发送数据，会造成永远阻塞如果从一个 nil 的channel 中接收数据，也会造成永久爱阻塞给一个已经关闭的 channel 发送数据， 会引起 pannic 从一个已经关闭的 channel 接收数据， 如果缓冲区中为空，则返回一个零值。</font></p>
<h2 id="10go-channel"><font style="color:rgb(0,0,0);">10、Go 语言当中 Channel 缓冲有什么特点？ </font><a class="headerlink" href="#10go-channel" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的。 </font></p>
<h2 id="11go-cap"><font style="color:rgb(0,0,0);">11、Go 语言中 cap 函数可以作用于那些内容？ </font><a class="headerlink" href="#11go-cap" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">cap 函数在讲引用的问题中已经提到，可以作用于的类型有： </font></p>
<ul>
<li><font style="color:rgb(0,0,0);">array(数组) </font></li>
<li><font style="color:rgb(0,0,0);">slice(切片) </font></li>
<li><font style="color:rgb(0,0,0);">channel(通道) </font></li>
</ul>
<h2 id="12go-convey"><font style="color:rgb(0,0,0);">12、go convey 是什么？一般用来做什么？ </font><a class="headerlink" href="#12go-convey" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">go convey 是一个支持 golang 的单元测试框架 </font></p>
<p><font style="color:rgb(0,0,0);">go convey 能够自动监控文件修改并启动测试，并可以将测试结果实时输出到 Web 界面 </font></p>
<p><font style="color:rgb(0,0,0);">go convey 提供了丰富的断言简化测试用例的编写 </font></p>
<h2 id="13go-new-make"><font style="color:rgb(0,0,0);">13、Go 语言当中 new 和 make 有什么区别吗？ </font><a class="headerlink" href="#13go-new-make" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">new 的作用是初始化一个纸箱类型的指针 new 函数是内建函数，函数定义： </font></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;func new(Type) *Type &lt;/font&gt;</code></p>
<ul>
<li><font style="color:rgb(0,0,0);">使用 new 函数来分配空间 </font></li>
<li><font style="color:rgb(0,0,0);">传递给 new 函数的是一个类型，而不是一个值 </font></li>
<li><font style="color:rgb(0,0,0);">返回值是指向这个新非配的地址的指针</font></li>
</ul>
<p><font style="color:rgb(0,0,0);"></font></p>
<h2 id="14go-make"><font style="color:rgb(0,0,0);">14、Go 语言中 make 的作用是什么？ </font><a class="headerlink" href="#14go-make" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">make 的作用是为 slice, map or chan 的初始化 然后返回引用 make 函数是内建函数，函数定义： </font></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;func make(Type, size IntegerType) Type&lt;/font&gt;</code><font style="color:rgb(0,0,0);"> </font></p>
<p><font style="color:rgb(0,0,0);">make(T, args) 函数的目的和 new(T) 不同 仅仅用于创建 slice, map, channel 而且返回类型是实例。 </font></p>
<h2 id="15printfsprintffprintf"><font style="color:rgb(0,0,0);">15、Printf(),Sprintf(),FprintF() 都是格式化输出，有什么不同？ </font><a class="headerlink" href="#15printfsprintffprintf" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">虽然这三个函数，都是格式化输出，但是输出的目标不一样 </font></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;Printf&lt;/font&gt;</code><font style="color:rgb(0,0,0);"> 是标准输出，一般是屏幕，也可以重定向。 </font></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;Sprintf()&lt;/font&gt;</code><font style="color:rgb(0,0,0);">是把格式化字符串输出到指定的字符串中。 </font></p>
<p><code>&lt;font style="color:rgb(18,18,18);"&gt;Fprintf()&lt;/font&gt;</code><font style="color:rgb(18,18,18);">是吧格式化字符串输出到文件中</font><font style="color:rgb(0,0,0);">。 </font></p>
<h2 id="16go"><font style="color:rgb(0,0,0);">16、Go 语言当中数组和切片的区别是什么？ </font><a class="headerlink" href="#16go" title="Permanent link">&para;</a></h2>
<p><strong><font style="color:rgb(0,0,0);">数组：</font></strong><font style="color:rgb(0,0,0);"> </font></p>
<p><font style="color:rgb(0,0,0);">数组固定长度数组长度是数组类型的一部分，所以 [3]int 和 [4]int 是两种不同的数组类型数组需要指定大小，不指定也会根据处初始化对的自动推算出大小，不可改变数组是通过值传递的 </font></p>
<p><strong><font style="color:rgb(0,0,0);">切片：</font></strong><font style="color:rgb(0,0,0);"> </font></p>
<p><font style="color:rgb(0,0,0);">切片可以改变长度切片是轻量级的数据结构，三个属性，指针，长度，容量不需要指定大小切片是地址传递（引用传递）可以通过数组来初始化，也可以通过内置函数 make() 来初始化，初始化的时候 </font><code>&lt;font style="color:rgb(0,0,0);"&gt;len=cap&lt;/font&gt;</code><font style="color:rgb(0,0,0);">，然后进行扩容</font></p>
<h2 id="17go"><font style="color:rgb(0,0,0);">17、Go 语言当中值传递和地址传递（引用传递）如何运用？有什</font><strong><font style="color:rgb(0,0,0);">么区别？举例说明。</font></strong><a class="headerlink" href="#17go" title="Permanent link">&para;</a></h2>
<ol>
<li><font style="color:rgb(0,0,0);">值传递只会把参数的值复制一份放进对应的函数，两个变量的地址不同，不可相互修改。 </font></li>
<li><font style="color:rgb(0,0,0);">地址传递(引用传递)会将变量本身传入对应的函数，在函数中可以对该变量进行值内容的修改。 </font></li>
</ol>
<h2 id="18go"><font style="color:rgb(0,0,0);">18、Go 语言当中数组和切片在传递的时候的区别是什么？ </font><a class="headerlink" href="#18go" title="Permanent link">&para;</a></h2>
<ol>
<li><font style="color:rgb(0,0,0);">数组是值传递</font></li>
<li><font style="color:rgb(0,0,0);">切片是引用传递 </font></li>
</ol>
<h2 id="19go"><font style="color:rgb(0,0,0);">19、Go 语言是如何实现切片扩容的？ </font><a class="headerlink" href="#19go" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">arr</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">2000</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;len 为&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;cap 为&quot;</span><span class="p">,</span><span class="w"> </span><span class="nb">cap</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span><span class="w"> </span>
<span class="w">        </span><span class="nx">arr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">append</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><font style="color:rgb(0,0,0);">我们可以看下结果: </font></p>
<p><font style="color:rgb(0,0,0);">0,1,2,4,8,16,32,64,128,256,512,1024 </font></p>
<p><font style="color:rgb(0,0,0);">但到了 1024 之后,就变成了</font></p>
<p><font style="color:rgb(0,0,0);">1024,1280,1696,2304</font></p>
<p><font style="color:rgb(0,0,0);">每次都是扩容了</font><strong><font style="color:rgb(0,0,0);">四分之一</font></strong><font style="color:rgb(0,0,0);">左右</font></p>
<p><font style="color:rgb(0,0,0);"></font></p>
<h2 id="20-defer-defer"><font style="color:rgb(0,0,0);">20、看下面代码的 defer 的执行顺序是什么？ defer 的作用和特 </font><a class="headerlink" href="#20-defer-defer" title="Permanent link">&para;</a></h2>
<p><strong><font style="color:rgb(0,0,0);">点是什么？ </font></strong></p>
<p><font style="color:rgb(0,0,0);">defer 的</font><strong><font style="color:rgb(0,0,0);">作用</font></strong><font style="color:rgb(0,0,0);">是： </font></p>
<p><font style="color:rgb(0,0,0);">你只需要在调用普通函数或方法前加上关键字 defer，就完成了 defer 所需要的语法。当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行。直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。 你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反。 </font></p>
<p><font style="color:rgb(0,0,0);">defer 的</font><strong><font style="color:rgb(0,0,0);">常用场景</font></strong><font style="color:rgb(0,0,0);">： </font></p>
<p><font style="color:rgb(0,0,0);">defer 语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。 </font></p>
<ul>
<li><font style="color:rgb(0,0,0);">通过 defer 机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。 </font></li>
<li><font style="color:rgb(0,0,0);">释放资源的 defer 应该直接跟在请求资源的语句后。 </font></li>
</ul>
<h2 id="21golang-slice"><font style="color:rgb(0,0,0);">21、Golang Slice 的底层实现 </font><a class="headerlink" href="#21golang-slice" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对</font><strong><font style="color:rgb(0,0,0);">底层数组的抽象</font></strong><font style="color:rgb(0,0,0);">。因为基于数组实现，所以它的底层的内存是</font><strong><font style="color:rgb(0,0,0);">连续分配</font></strong><font style="color:rgb(0,0,0);">的，效率非常高，还可以通过索引获得数据，可以迭代以及垃圾回收优化。</font></p>
<p><font style="color:rgb(0,0,0);">切片本身并</font><strong><font style="color:rgb(0,0,0);">不是动态数组或者数组指针</font></strong><font style="color:rgb(0,0,0);">。它内部实现的数据结构</font><strong><font style="color:rgb(0,0,0);">通过指针引用底层数组</font></strong><font style="color:rgb(0,0,0);">，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个</font><strong><font style="color:rgb(0,0,0);">只读对象</font></strong><font style="color:rgb(0,0,0);">，其工作机制类似</font><strong><font style="color:rgb(0,0,0);">数组指针的一种封装</font></strong><font style="color:rgb(0,0,0);">。 </font></p>
<p><font style="color:rgb(0,0,0);">切片对象非常小，是因为它是只有 </font><font style="color:rgb(0,0,0);">3 个字段的数据结构： </font></p>
<ol>
<li><font style="color:rgb(0,0,0);">指向底层数组的指针 </font></li>
<li><font style="color:rgb(0,0,0);">切片的长度 </font></li>
<li><font style="color:rgb(0,0,0);">切片的容量</font></li>
</ol>
<h2 id="22golang-slice"><font style="color:rgb(0,0,0);">22、Golang Slice 的扩容机制，有什么注意点？ </font><a class="headerlink" href="#22golang-slice" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">Go 中切片扩容的策略是这样的： </font></p>
<ol>
<li><font style="color:rgb(0,0,0);">首先判断，如果新申请容量大于 2 倍的旧容量，最终容量就是新申请的容量</font></li>
<li><font style="color:rgb(0,0,0);">否则判断，如果旧切片的长度小于 1024，则最终容量就是旧容量的两倍</font></li>
<li><font style="color:rgb(0,0,0);">否则判断，如果旧切片长度大于等于 1024，则最终容量从旧容量开始循环，增加原来的 1/4, 直到最终容量大于等于新申请的容量</font></li>
<li><font style="color:rgb(0,0,0);">如果最终容量计算值溢出，则最终容量就是新申请容量 </font></li>
</ol>
<h2 id="23-slice"><font style="color:rgb(0,0,0);">23、</font><font style="color:rgb(51,51,51);">扩容前后的 Slice 是否相同？ </font><a class="headerlink" href="#23-slice" title="Permanent link">&para;</a></h2>
<p><strong><font style="color:rgb(0,0,0);">情况一：</font></strong><font style="color:rgb(0,0,0);"> </font></p>
<p><font style="color:rgb(0,0,0);">原数组还有容量可以扩容（实际容量没有填充完），这种情况下，扩容以后的 </font></p>
<p><font style="color:rgb(0,0,0);">数组还是指向原来的数组，对一个切片的操作可能影响多个指针指向相同地址 </font></p>
<p><font style="color:rgb(0,0,0);">的 Slice。 </font></p>
<p><strong><font style="color:rgb(0,0,0);">情况二： </font></strong></p>
<p><font style="color:rgb(0,0,0);">原来数组的容量已经达到了最大值，再想扩容， Go 默认会先开一片内存区 </font></p>
<p><font style="color:rgb(0,0,0);">域，把原来的值拷贝过来，然后再执行 append() 操作。这种情况丝毫不影响 </font></p>
<p><font style="color:rgb(0,0,0);">原数组。 </font></p>
<p><font style="color:rgb(0,0,0);">要复制一个 Slice，最好使用 Copy 函数。 </font></p>
<h2 id="24golang"><font style="color:rgb(0,0,0);">24、Golang 的参数传递、引用类型 </font><a class="headerlink" href="#24golang" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">Go 语言中所有的传参都是</font><strong><font style="color:rgb(0,0,0);">值传递（传值）</font></strong><font style="color:rgb(0,0,0);">，都是一个副本，一个拷贝。</font></p>
<p><font style="color:rgb(0,0,0);">因为拷贝的内容有时候是</font><strong><font style="color:rgb(0,0,0);">非引用类型</font></strong><font style="color:rgb(0,0,0);">（int、string、struct 等这些），这样就在函数中就无法修改原内容数据；</font></p>
<p><font style="color:rgb(0,0,0);">有的是</font><strong><font style="color:rgb(0,0,0);">引用类型</font></strong><font style="color:rgb(0,0,0);">（指针、map、slice、chan 等这些），这样就可以修改原内容数据。</font></p>
<p><font style="color:rgb(0,0,0);">Golang 的引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除了申请内存外，还需要初始化相关属性。内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。</font></p>
<h2 id="25golang-map"><font style="color:rgb(0,0,0);">25、Golang Map 底层实现 </font><a class="headerlink" href="#25golang-map" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(51,51,51);">Golang 中 map 的底层实现是一个散列表，因此实现 map 的过程实际上就是实现散表的过程。在这个散列表中，主要出现的结构体有两个，一个叫 hmap(a header for a go map)，一个叫 bmap(a bucket for a Go map，通常叫其 bucket)。 </font></p>
<h2 id="26golang-map"><font style="color:rgb(0,0,0);">26、Golang Map 如何扩容 </font><a class="headerlink" href="#26golang-map" title="Permanent link">&para;</a></h2>
<p><strong><font style="color:rgb(0,0,0);">装载因子</font></strong><font style="color:rgb(0,0,0);">：count/2^B </font></p>
<p><strong><font style="color:rgb(0,0,0);">触发条件</font></strong><font style="color:rgb(0,0,0);">： </font></p>
<ol>
<li><font style="color:rgb(0,0,0);">装填因子是否大于 6.5 </font></li>
<li><font style="color:rgb(0,0,0);">overflow bucket 是否太多 </font></li>
</ol>
<p><strong><font style="color:rgb(0,0,0);">解决方法</font></strong><font style="color:rgb(0,0,0);">： </font></p>
<ol>
<li><font style="color:rgb(0,0,0);">双倍扩容：扩容采取了一种称为“渐进式”地方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket</font></li>
<li><font style="color:rgb(0,0,0);">等量扩容：重新排列，极端情况下，重新排列也解决不了，map 成了链表，性能大大降低，此时哈希种子 hash0 的设置，可以降低此类极端场景的发生</font></li>
</ol>
<h2 id="27golang-map"><font style="color:rgb(0,0,0);">27、Golang Map 查找 </font><a class="headerlink" href="#27golang-map" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(51,51,51);">Go 语言中 map 采用的是哈希查找表，由一个 key 通过哈希函数得到哈希值，64位系统中就生成一个64bit 的哈希值，由这个哈希值将 key 对应到不同的桶（bucket）中，当有多个哈希映射到相同的的桶中时，使用链表解决哈希冲突。</font><font style="color:rgb(0,0,0);">key 经过 hash 后共 64 位，根据 hmap 中 B 的值，计算它到底要落在哪个桶时，桶的数量为 2^B，如 B=5，那么用 64 位最后 5 位表示第几号桶，在用 hash值的高 8 位确定在bucket 中的存储位置，当前 bmap 中的 bucket 未找到，则查询对应的 overflow bucket，对应位置有数据则对比完整的哈希值，确定是否是要查找的数据。 </font></p>
<p><font style="color:rgb(0,0,0);">如果两个不同的 key 落在的同一个桶上，hash 冲突使用链表法接近，遍历bucket 中的 key 如果当前处于 map 进行了扩容，处于数据搬移状态，则优先从oldbuckets 查找。 </font></p>
<h2 id="28-channel"><font style="color:rgb(0,0,0);">28、介绍一下 Channel </font><a class="headerlink" href="#28-channel" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">Go 语言中，不要通过共享内存来通信，而要通过通信来实现内存共享。Go 的CSP (Communicating Sequential Process)并发模型，中文可以叫做通信顺序进程，是通过 goroutine 和 channel 来实现的。 </font></p>
<p><font style="color:rgb(0,0,0);">所以 channel 收发遵循先进先出 FIFO，分为有缓存和无缓存，channel 中大致有 buffer(当缓冲区大小部位 0 时，是个 ring buffer)、sendx 和 recvx 收发的位置(ring buffer 记录实现)、sendq、recvq 当前channel 因为缓冲区不足而阻塞的队列、使用双向链表存储、还有一个 mutex 锁控制并发、其他原属等。 </font></p>
<h2 id="29go-channel"><font style="color:rgb(0,0,0);">29、Go 语言的 Channel 特性？ </font><a class="headerlink" href="#29go-channel" title="Permanent link">&para;</a></h2>
<ol>
<li><font style="color:rgb(0,0,0);">给一个 nil channel 发送数据，造成永远阻塞 </font></li>
<li><font style="color:rgb(0,0,0);">从一个 nil channel 接收数据，造成永远阻塞</font></li>
<li><font style="color:rgb(0,0,0);">给一个已经关闭的 channel 发送数据，引起 panic </font></li>
<li><font style="color:rgb(0,0,0);">从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值 </font></li>
<li><font style="color:rgb(0,0,0);">无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的</font></li>
<li><font style="color:rgb(0,0,0);">关闭一个 nil channel 将会发生 panic </font></li>
</ol>
<h2 id="30channel-ring-buffer"><font style="color:rgb(0,0,0);">30、Channel 的 ring buffer 实现 </font><a class="headerlink" href="#30channel-ring-buffer" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">channel 中使用了 ring buffer(环形缓冲区) 来缓存写入的数据。ring buffer 有很多好处，而且非常适合用来实现 FIFO 式的固定长度队列。 </font></p>
<p><font style="color:rgb(0,0,0);">在 channel 中，ring buffer 的实现如下：</font></p>
<p><img alt="1648110902143-0b71f5bc-4ef8-43e0-896a-9df680964b8e.png" src="../img/wwUuaFWMcSbI8uEp/1648110902143-0b71f5bc-4ef8-43e0-896a-9df680964b8e-794472.png" /></p>
<p><font style="color:rgb(0,0,0);">hchan 中有两个与 buffer 相关的变量:recvx 和 sendx。其中 sendx 表示buffer 中可写的 index，recvx 表示buffer 中可读的 index。 从 recvx 到sendx 之间的元素，表示已正常存放入 buffer 中的数据。 </font></p>
<p><font style="color:rgb(0,0,0);">我们可以直接使用 buf[recvx]来读取到队列的第一个元素，使用 buf[sendx] = x 来将元素放到队尾。</font></p>
<h1 id="go"><font style="color:rgb(0,0,0);">Go 并发编程 </font><a class="headerlink" href="#go" title="Permanent link">&para;</a></h1>
<h2 id="1mutex"><font style="color:rgb(0,0,0);">1、Mutex 几种状态 </font><a class="headerlink" href="#1mutex" title="Permanent link">&para;</a></h2>
<ul>
<li><font style="color:rgb(0,0,0);">mutexLocked — 表示互斥锁的锁定状态； </font></li>
<li><font style="color:rgb(0,0,0);">mutexWoken — 表示从正常模式被从唤醒； </font></li>
<li><font style="color:rgb(0,0,0);">mutexStarving — 当前的互斥锁进入饥饿状态； </font></li>
<li><font style="color:rgb(0,0,0);">waitersCount — 当前互斥锁上等待的 Goroutine 个数； </font></li>
</ul>
<h2 id="2mutex"><font style="color:rgb(0,0,0);">2、Mutex 正常模式和饥饿模式 </font><a class="headerlink" href="#2mutex" title="Permanent link">&para;</a></h2>
<h3 id="_2"><font style="color:rgb(0,0,0);">正常模式(非公平锁) </font><a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p><font style="color:rgb(0,0,0);">正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。唤醒的goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁的拥有。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的 goroutine 会加入到等待队列的前面。 如果一个等待的 goroutine 超过1ms 没有获取锁，那么它将会把锁转变为饥饿模式。 </font></p>
<h3 id="_3"><font style="color:rgb(0,0,0);">饥饿模式(公平锁) </font><a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p><font style="color:rgb(0,0,0);">为了解决了等待 G 队列的长尾问题饥饿模式下，直接由 unlock 把锁交给等待队列中排在第一位的 G(队头)，同时，饥饿模式下，新进来的 G 不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部,这样很好的解决了老的 g 一直抢不到锁的场景。饥饿模式的触发条件，当一个 G 等待锁时间超过 1 毫秒时，或者当前队列只剩下一个 g 的时候，Mutex 切换到饥饿模式。</font></p>
<h3 id="_4"><font style="color:rgb(0,0,0);">总结</font><a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p><font style="color:rgb(0,0,0);">对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的一个平衡模式。</font></p>
<h2 id="3mutex"><font style="color:rgb(0,0,0);">3、Mutex 允许自旋的条件 </font><a class="headerlink" href="#3mutex" title="Permanent link">&para;</a></h2>
<ol>
<li><font style="color:rgb(0,0,0);">锁已被占用，并且锁不处于饥饿模式。 </font></li>
<li><font style="color:rgb(0,0,0);">积累的自旋次数小于最大自旋次数（active_spin=4）。 </font></li>
<li><font style="color:rgb(0,0,0);">cpu 核数大于 1。 </font></li>
<li><font style="color:rgb(0,0,0);">有空闲的 P。 </font></li>
<li><font style="color:rgb(0,0,0);">当前 goroutine 所挂载的 P 下，本地待运行队列为空。 </font></li>
</ol>
<h2 id="4rwmutex"><font style="color:rgb(0,0,0);">4、RWMutex 实现 </font><a class="headerlink" href="#4rwmutex" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">通过记录 readerCount 读锁的数量来进行控制，当有一个写锁的时候，会将读锁数量设置为负数 1&lt;&lt;30。目的是让新进入的读锁等待写锁之后释放通知读锁。同样的写锁也会等等待之前的读锁都释放完毕，才会开始进行后续的操作。 而等写锁释放完之后，会将值重新加上 1&lt;&lt;30, 并通知刚才新进入的读锁</font></p>
<p><font style="color:rgb(0,0,0);">(rw.readerSem)，两者互相限制。</font></p>
<h2 id="5rwmutex"><font style="color:rgb(0,0,0);">5、RWMutex 注意事项</font><a class="headerlink" href="#5rwmutex" title="Permanent link">&para;</a></h2>
<ul>
<li><font style="color:rgb(0,0,0);">RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁 </font></li>
<li><font style="color:rgb(0,0,0);">读锁占用的情况下会阻止写，不会阻止读，多个 goroutine 可以同时获取读锁 </font></li>
<li><font style="color:rgb(0,0,0);">写锁会阻止其他 goroutine（无论读和写）进来，整个锁由该 goroutine 独占 </font></li>
<li><font style="color:rgb(0,0,0);">适用于读多写少的场景</font></li>
<li><font style="color:rgb(0,0,0);">RWMutex 类型变量的零值是一个未锁定状态的互斥锁。 </font></li>
<li><font style="color:rgb(0,0,0);">RWMutex 在首次被使用之后就不能再被拷贝。 </font></li>
<li><font style="color:rgb(0,0,0);">RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发 panic。 </font></li>
<li><font style="color:rgb(0,0,0);">RWMutex 的一个写锁 </font><code>**Lock**&lt;font style="color:rgb(10,191,91);"&gt;&lt;/font&gt;</code><font style="color:rgb(0,0,0);">去锁定临界区的共享资源，如果临界区的共享资源已被（读锁或写锁）锁定，这个写锁操作的 goroutine 将被阻塞直到解锁。 </font></li>
<li><font style="color:rgb(0,0,0);">RWMutex 的读锁不要用于递归调用，比较容易产生死锁。 </font></li>
<li><font style="color:rgb(0,0,0);">RWMutex 的锁定状态与特定的 goroutine 没有关联。一个 goroutine 可以 RLock（Lock），另一个 goroutine 可以 RUnlock（Unlock）。 </font></li>
<li><font style="color:rgb(0,0,0);">写锁被解锁后，所有因操作锁定读锁而被阻塞的 goroutine 会被唤醒，并都可以成功锁定读锁。 </font></li>
<li><font style="color:rgb(0,0,0);">读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而被阻塞的 goroutine，其中等待时间最长的一个 goroutine 会被唤醒。</font></li>
</ul>
<h2 id="6cond"><font style="color:rgb(0,0,0);">6、Cond 是什么 </font><a class="headerlink" href="#6cond" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">Cond 实现了一种条件变量，可以使用在多个 Reader 等待共享资源 ready 的场景（如果只有一读一写，一个锁或者 channel 就搞定了）每个 Cond 都会关联一个 Lock（<em>sync.Mutex or </em>sync.RWMutex），当修改条件或者调用Wait 方法时，必须加锁，保护 condition。 </font></p>
<h2 id="7broadcast-signal"><font style="color:rgb(0,0,0);">7、Broadcast 和 Signal 区别 </font><a class="headerlink" href="#7broadcast-signal" title="Permanent link">&para;</a></h2>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;func (c *Cond) Broadcast() &lt;/font&gt;</code></p>
<p><font style="color:rgb(0,0,0);">Broadcast 会唤醒</font><font style="color:rgb(0,0,0);">所有</font><font style="color:rgb(0,0,0);">等待 c 的 goroutine。 </font></p>
<p><font style="color:rgb(0,0,0);">调用 Broadcast 的时候，可以加锁，也可以不加锁。</font></p>
<p><code>&lt;font style="color:rgb(0,0,0);"&gt;func (c *Cond) Signal() &lt;/font&gt;</code></p>
<p><font style="color:rgb(0,0,0);">Signal 只唤醒 </font><font style="color:rgb(0,0,0);">1 个</font><font style="color:rgb(0,0,0);">等待 c 的 goroutine。 </font></p>
<p><font style="color:rgb(0,0,0);">调用 Signal 的时候，可以加锁，也可以不加锁。</font></p>
<h2 id="8cond-wait"><font style="color:rgb(0,0,0);">8、Cond 中 Wait 使用 </font><a class="headerlink" href="#8cond-wait" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">func (c *Cond) Wait() </font></p>
<p><font style="color:rgb(0,0,0);">Wait()会自动释放 c.L，并挂起调用者的 goroutine。之后恢复执行，Wait()会在返回时对 c.L 加锁。 </font></p>
<p><font style="color:rgb(0,0,0);">除非被 Signal 或者 Broadcast 唤醒，否则 Wait()不会返回。 </font></p>
<p><font style="color:rgb(0,0,0);">由于 Wait()第一次恢复时，C.L 并没有加锁，所以当 Wait 返回时，调用者通常并不能假设条件为真。 </font></p>
<p><font style="color:rgb(0,0,0);">取而代之的是, 调用者应该在循环中调用 Wait。（简单来说，只要想使用condition，就必须加锁。） </font></p>
<p><font style="color:rgb(0,0,0);">c.L.Lock() </font></p>
<p><font style="color:rgb(0,0,0);">for !condition() { </font></p>
<p><font style="color:rgb(0,0,0);"> c.Wait() </font></p>
<p><font style="color:rgb(0,0,0);">} </font></p>
<p><font style="color:rgb(0,0,0);">... make use of condition ... </font></p>
<p><font style="color:rgb(0,0,0);">c.L.Unlock() </font></p>
<h2 id="9waitgroup"><font style="color:rgb(0,0,0);">9、WaitGroup 用法 </font><a class="headerlink" href="#9waitgroup" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">一个 WaitGroup 对象可以等待一组协程结束。</font><strong><font style="color:rgb(0,0,0);">使用方法是</font></strong><font style="color:rgb(0,0,0);">： </font></p>
<ol>
<li><font style="color:rgb(0,0,0);">main 协程通过调用 wg.Add(delta int) 设置 worker 协程的个数，然后创建 worker 协程； </font></li>
<li><font style="color:rgb(0,0,0);">worker 协程执行结束以后，都要调用 wg.Done()；</font></li>
<li><font style="color:rgb(0,0,0);">main 协程调用 wg.Wait() 且被 block，直到所有 worker 协程全部执行结束后返回。</font></li>
</ol>
<h2 id="10waitgroup"><font style="color:rgb(0,0,0);">10、WaitGroup 实现原理 </font><a class="headerlink" href="#10waitgroup" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">WaitGroup 主要维护了 2 个计数器，一个是请求计数器 v，一个是等待计数器 w，二者组成一个 64bit 的值，请求计数器占高 32bit，等待计数器占低32bit。 </font></p>
<p><font style="color:rgb(0,0,0);">每次 Add 执行，请求计数器 v 加 1，Done 方法执行，请求计数器减 1，v 为0 时通过信号量唤醒 Wait()。 </font></p>
<h2 id="11-synconce"><font style="color:rgb(0,0,0);">11、什么是 sync.Once </font><a class="headerlink" href="#11-synconce" title="Permanent link">&para;</a></h2>
<ul>
<li><font style="color:rgb(0,0,0);">Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。 </font></li>
<li><font style="color:rgb(0,0,0);">Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。 </font></li>
<li><font style="color:rgb(0,0,0);">sync.Once 只暴露了一个方法 Do，你可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回值的函数。 </font></li>
</ul>
<h2 id="12"><font style="color:rgb(0,0,0);">12、什么操作叫做原子操作 </font><a class="headerlink" href="#12" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">一个或者多个操作在 CPU 执行过程中不被中断的特性，称为原子性(atomicity)。这些操作对外表现成一个不可分割的整体，他们要么都执行，要么都不执行，外界不会看到他们只执行到一半的状态。而在现实世界中，CPU不可能不中断的执行一系列操作，但如果我们在执行多个操作时，能让他们的中间状态对外不可见，那我们就可以宣城他们拥有了“不可分割”的原子性。</font></p>
<p><font style="color:rgb(0,0,0);">在 Go 中，一条普通的赋值语句其实不是一个原子操作。列如，在 32 位机器上写 int64 类型的变量就会有中间状态，因为他会被拆成两次写操作(MOV)——写低 32 位和写高 32 位。 </font></p>
<h2 id="13"><font style="color:rgb(0,0,0);">13、原子操作和锁的区别 </font><a class="headerlink" href="#13" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(51,51,51);">原子操作由底层硬件支持，而锁则由操作系统的调度器实现。锁应当用来保护一段逻辑，对于一个变量更新的保护，原子操作通常会更有效率，并且更能利用计算机多核的优势，如果要更新的是一个复合对象，则应当使用</font><code>&lt;font style="color:rgb(255,80,44);"&gt;atomic.Value &lt;/font&gt;</code><font style="color:rgb(51,51,51);">封装好的实现。</font></p>
<h2 id="14-cas"><font style="color:rgb(0,0,0);">14、什么是 CAS </font><a class="headerlink" href="#14-cas" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">CAS 的全称为 </font><font style="color:rgb(199,37,78);">Compare And Swap</font><font style="color:rgb(0,0,0);">，直译就是比较交换。是一条 CPU 的原子指令，其作用是让 </font><font style="color:rgb(199,37,78);">CPU </font><font style="color:rgb(0,0,0);">先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令，在 </font><font style="color:rgb(199,37,78);">intel </font><font style="color:rgb(0,0,0);">的 </font><font style="color:rgb(199,37,78);">CPU </font><font style="color:rgb(0,0,0);">中，使用的</font><font style="color:rgb(199,37,78);">cmpxchg </font><font style="color:rgb(0,0,0);">指令，就是说 </font><font style="color:rgb(199,37,78);">CAS </font><font style="color:rgb(0,0,0);">是靠硬件实现的，从而在硬件层面提升效率。 </font></p>
<p><strong><font style="color:rgb(0,0,0);">简述过程是这样：</font></strong><font style="color:rgb(0,0,0);"> </font></p>
<p><font style="color:rgb(0,0,0);">假设包含 3 个参数内存位置(V)、预期原值(A)和新值(B)。V 表示要更新变量的值，E 表示预期值，N 表示新值。仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程在做更新，则当前线程什么都不做，最后 CAS 返回当前 V 的真实值。CAS 操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对于当前线程的干扰。</font></p>
<h2 id="15syncpool"><font style="color:rgb(0,0,0);">15、sync.Pool 有什么用 </font><a class="headerlink" href="#15syncpool" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">对于很多需要重复分配、回收内存的地方，</font><font style="color:rgb(232,62,140);">sync.Pool </font><font style="color:rgb(0,0,0);">是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 </font><font style="color:rgb(232,62,140);">sync.Pool </font><font style="color:rgb(0,0,0);">可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。</font></p>
<h1 id="go-runtime"><font style="color:rgb(0,0,0);">Go Runtime </font><a class="headerlink" href="#go-runtime" title="Permanent link">&para;</a></h1>
<h2 id="1goroutine"><font style="color:rgb(0,0,0);">1、Goroutine 定义 </font><a class="headerlink" href="#1goroutine" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">Goroutine 是一个与其他 goroutines 并行运行在同一地址空间的 Go 函数或方法。一个运行的程序由一个或更多个 goroutine 组成。它与线程、协程、进程等不同。它是一个 goroutine” —— Rob Pike </font></p>
<p><font style="color:rgb(0,0,0);">Goroutines 在同一个用户地址空间里并行独立执行 functions，channels 则用于 goroutines 间的通信和同步访问控制。 </font></p>
<h2 id="2gmp"><font style="color:rgb(0,0,0);">2、GMP 指的是什么 </font><a class="headerlink" href="#2gmp" title="Permanent link">&para;</a></h2>
<p><strong><font style="color:rgb(0,0,0);">G（Goroutine）</font></strong><font style="color:rgb(0,0,0);">：我们所说的协程，为用户级的轻量级线程，每个 Goroutine对象中的 sched 保存着其上下文信息.。</font></p>
<p><strong><font style="color:rgb(0,0,0);">M（Machine）</font></strong><font style="color:rgb(0,0,0);">：对内核级线程的封装，数量对应真实的 CPU 数（真正干活的对象）。</font></p>
<p><strong><font style="color:rgb(0,0,0);">P（Processor）</font></strong><font style="color:rgb(0,0,0);">：即为 G 和 M 的调度对象，用来调度 G 和 M 之间的关联关系，其数量可通过GOMAXPROCS()来设置，默认为核心数。</font></p>
<h2 id="310-gm"><font style="color:rgb(0,0,0);">3、1.0 之前 GM 调度模型 </font><a class="headerlink" href="#310-gm" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">调度器把 G 都分配到 M 上，不同的 G 在不同的 M 并发运行时，都需要向系统申请资源，比如堆栈内存等，因为资源是全局的，就会因为资源竞争照成很多性能损耗。为了解决这一的问题 go 从 1.1 版本引入，在运行时系统的时候加入 p 对象，让 P 去管理这个 G 对象，M 想要运行 G，必须绑定 P，才能运行 P 所管理的 G。</font></p>
<ol>
<li><font style="color:rgb(0,0,0);">单一全局互斥锁(Sched.Lock)和集中状态存储</font></li>
<li><font style="color:rgb(0,0,0);">Goroutine 传递问题（M 经常在 M 之间传递”可运行”的 goroutine）</font></li>
<li><font style="color:rgb(0,0,0);">每个 M 做内存缓存，导致内存占用过高，数据局部性较差</font></li>
<li><font style="color:rgb(0,0,0);">频繁 syscall 调用，导致严重的线程阻塞/解锁，加剧额外的性能损耗</font></li>
</ol>
<h2 id="4gmp"><font style="color:rgb(0,0,0);">4、GMP 调度流程</font><img alt="1648111683893-f2a6a9c6-c6ea-484b-b59c-e3afb5ec3fa7.png" src="../img/wwUuaFWMcSbI8uEp/1648111683893-f2a6a9c6-c6ea-484b-b59c-e3afb5ec3fa7-864873.png" /><a class="headerlink" href="#4gmp" title="Permanent link">&para;</a></h2>
<ul>
<li><font style="color:rgb(0,0,0);">每个 P 有个局部队列，局部队列保存待执行的 goroutine(流程 2)，当 M 绑定的 P 的的局部队列已经满了之后就会把 goroutine 放到全局队列(流程 2-1)</font></li>
<li><font style="color:rgb(0,0,0);">每个 P 和一个 M 绑定，M 是真正的执行 P 中 goroutine 的实体(流程 3)，M 从绑定的 P 中的局部队列获取 G 来执行</font></li>
<li><font style="color:rgb(0,0,0);">当 M 绑定的 P 的局部队列为空时，M 会从全局队列获取到本地队列来执行G(流程 3.1)，当从全局队列中没有获取到可执行的 G 时候，M 会从其他 P的局部队列中偷取 G 来执行(流程 3.2)，这种从其他 P 偷的方式称为 work stealing  </font></li>
<li><font style="color:rgb(0,0,0);">当 G 因系统调用(syscall)阻塞时会阻塞 M，此时 P 会和 M 解绑即 hand off，并寻找新的 idle 的 M，若没有 idle 的 M 就会新建一个 M(流程 5.1)。</font></li>
<li><font style="color:rgb(0,0,0);">当 G 因 channel 或者 network I/O 阻塞时，不会阻塞 M，M 会寻找其他runnable 的 G；当阻塞的 G 恢复后会重新进入 runnable 进入 P 队列等待执行(流程 5.3)</font></li>
</ul>
<h2 id="5gmp-work-stealing"><font style="color:rgb(0,0,0);">5、GMP 中 </font><font style="color:rgb(51,51,51);">work stealing 机制 </font><a class="headerlink" href="#5gmp-work-stealing" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(51,51,51);">存到 P 本地队列或者是全局队列。P 此时去唤醒一个 M。P 继续执行它的执行序。M 寻找是否有空闲的 P，如果有则将该 G 对象移动到它本身。接下来 M 执行一个调度循环(调用 G 对象-&gt;执行-&gt;清理线程→继续找新的Goroutine 执行)。</font></p>
<h2 id="6gmp-hand-off"><font style="color:rgb(51,51,51);">6、GMP 中 hand off 机制</font><a class="headerlink" href="#6gmp-hand-off" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">当本线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M'执行。当发生上线文切换时，需要对执行现场进行保护，以便下次被调度执行时进行现场恢复。Go 调度器 M 的栈保存在 G 对象上，只需要将 M 所需要的寄存器(SP、PC 等)保存到 G 对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以做上下文切换了，在中断之前把现场保存起来。如果此时 G 任务还没有执行完，M 可以将任务重新丢到 P 的任务队列，等待下一次被调度执行。当再次被调度执行时，M 通过访问 G 的 vdsoSP、vdsoPC 寄存器进行现场恢复(从上次中断位置继续执行)</font></p>
<h2 id="7"><font style="color:rgb(0,0,0);">7、协作式的抢占式调度 </font><a class="headerlink" href="#7" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">在 1.14 版本之前，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度，存在问题 ：</font></p>
<ol>
<li><font style="color:rgb(0,0,0);">某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿。</font></li>
<li><font style="color:rgb(0,0,0);">垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作。</font></li>
</ol>
<h2 id="8"><font style="color:rgb(0,0,0);">8、基于信号的抢占式调度</font><a class="headerlink" href="#8" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(51,51,51);">在任何情况下，Go 运行时并行执行（注意，不是并发）的 goroutines 数量是小于等于 P 的数量的。为了提高系统的性能，P 的数量肯定不是越小越好，所以官方默认值就是 CPU 的核心数，设置的过小的话，如果一个持有 P 的 M，由于 P 当前执行的 G 调用了 syscall 而导致 M 被阻塞，那么此时关键点： GO 的调度器是迟钝的，它很可能什么都没做，直到 M 阻塞了相当长时间以后，才会发现有一个 P/M 被 syscall 阻塞了。然后，才会用空闲的 M 来强这个 P。通过 sysmon 监控实现的抢占式调度，最快在 20us，最慢在 10-20ms 才会发现有一个 M 持有 P 并阻塞了。操作系统在 1ms 内可以完成很多次线程调度（一般情况 1ms 可以完成几十次线程调度），Go 发起 IO/syscall 的时候执行该 G 的 M 会阻塞然后被 OS 调度走，P 什么也不干，sysmon 最慢要 10-20ms 才能发现这个阻塞，说不定那时候阻塞已经结束了，宝贵的 P 资源就这么被阻塞的 M 浪费了。</font></p>
<h2 id="9gmp"><font style="color:rgb(51,51,51);">9、GMP </font><font style="color:rgb(0,0,0);">调度过程中存在哪些阻塞 </font><a class="headerlink" href="#9gmp" title="Permanent link">&para;</a></h2>
<ul>
<li><font style="color:rgb(0,0,0);">I/O，select </font></li>
<li><font style="color:rgb(0,0,0);">block on syscall </font></li>
<li><font style="color:rgb(0,0,0);">channel </font></li>
<li><font style="color:rgb(0,0,0);">等待锁30 </font></li>
<li><font style="color:rgb(0,0,0);">runtime.Gosched() </font></li>
</ul>
<h2 id="10sysmon"><font style="color:rgb(0,0,0);">10、sysmon 有什么作用 </font><a class="headerlink" href="#10sysmon" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">sysmon 也叫监控线程，变动的周期性检查，好处：</font></p>
<ul>
<li><font style="color:rgb(0,0,0);">释放闲置超过 5 分钟的 span 物理内存； </font></li>
<li><font style="color:rgb(0,0,0);">如果超过 2 分钟没有垃圾回收，强制执行； </font></li>
<li><font style="color:rgb(0,0,0);">将长时间未处理的 netpoll 添加到全局队列； </font></li>
<li><font style="color:rgb(0,0,0);">向长时间运行的 G 任务发出抢占调度(超过 10ms 的 g，会进行 retake)； </font></li>
<li><font style="color:rgb(0,0,0);">收回因 syscall 长时间阻塞的 P； </font></li>
</ul>
<h2 id="11"><font style="color:rgb(0,0,0);">11、三色标记原理 </font><a class="headerlink" href="#11" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(33,37,41);">我们首先看一张图，大概就会对 三色标记法有一个大致的了解：</font></p>
<p><img alt="1648112126027-9c3e4faa-171c-46ae-8e57-636fb7c61e6b.png" src="../img/wwUuaFWMcSbI8uEp/1648112126027-9c3e4faa-171c-46ae-8e57-636fb7c61e6b-468051.png" /></p>
<p><strong><font style="color:rgb(0,0,0);">原理</font></strong><font style="color:rgb(0,0,0);">： </font></p>
<ol>
<li><font style="color:rgb(0,0,0);">首先把所有的对象都放到白色的集合中</font></li>
<li><font style="color:rgb(0,0,0);">从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中</font></li>
<li><font style="color:rgb(0,0,0);">循环步骤 3，知道灰色集合中没有对象</font></li>
<li><font style="color:rgb(0,0,0);">步骤 4 结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收</font></li>
</ol>
<h2 id="12_1"><font style="color:rgb(0,0,0);">12、</font><font style="color:rgb(51,51,51);">插入写屏障 </font><a class="headerlink" href="#12_1" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(51,51,51);">golang 的回收没有混合屏障之前，一直是插入写屏障，由于栈赋值没有 hook 的原因，所以栈中没有启用写屏障，所以有 STW。golang 的解决方法是：只是需要在结束时启动 STW 来重新扫描栈。这个自然就会导致整个进程的赋值器卡顿，所以后面 golang 是引用混合写屏障解决这个问题。混合写屏障之后，就没有 STW。</font></p>
<h2 id="13_1"><font style="color:rgb(51,51,51);">13、</font><font style="color:rgb(0,0,0);">删除写屏障 </font><a class="headerlink" href="#13_1" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">goalng 没有这一步，golang 的内存写屏障是由插入写屏障到混合写屏障过渡的。简单介绍一下，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。</font></p>
<h2 id="14"><font style="color:rgb(0,0,0);">14、 写屏障 </font><a class="headerlink" href="#14" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">Go 在进行三色标记的时候并没有 STW，也就是说，此时的对象还是可以进行修改。</font></p>
<p><font style="color:rgb(0,0,0);">那么我们考虑一下，下面的情况。</font></p>
<p><img alt="1648112214805-fe202703-942d-4f5f-b1ab-5c54f87b69e8.png" src="../img/wwUuaFWMcSbI8uEp/1648112214805-fe202703-942d-4f5f-b1ab-5c54f87b69e8-244272.png" /></p>
<p><font style="color:rgb(0,0,0);">我们在进行三色标记中扫描灰色集合中，扫描到了对象 A，并标记了对象 A 的 所有引用，这时候，开始扫描对象 D 的引用，而此时，另一个 goroutine 修改了 D-&gt;E 的引用，变成了如下图所示：</font></p>
<p><img alt="1648112242164-e67f2048-79fd-4cc3-a7ed-04705dddaa2d.png" src="../img/wwUuaFWMcSbI8uEp/1648112242164-e67f2048-79fd-4cc3-a7ed-04705dddaa2d-432658.png" /></p>
<p><font style="color:rgb(0,0,0);">这样会不会导致 E 对象就扫描不到了，而被误认为为白色对象，也就是垃圾写屏障就是为了解决这样的问题，引入写屏障后，在上述步骤后，E 会被认为是存活的，即使后面 E 被 A 对象抛弃，E 会被在下一轮的 GC 中进行回收，这一轮 GC 中是不会对对象 E 进行回收的。</font></p>
<h2 id="15"><font style="color:rgb(0,0,0);">15、混合写屏障 </font><a class="headerlink" href="#15" title="Permanent link">&para;</a></h2>
<ul>
<li><font style="color:rgb(0,0,0);">混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可； </font></li>
<li><font style="color:rgb(0,0,0);">混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC 期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈；</font></li>
<li><font style="color:rgb(0,0,0);">混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是 GC 过程全程无 STW； </font></li>
<li><font style="color:rgb(0,0,0);">混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作的哈（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）。 </font></li>
</ul>
<h2 id="16gc"><font style="color:rgb(0,0,0);">16、GC 触发时机</font><a class="headerlink" href="#16gc" title="Permanent link">&para;</a></h2>
<h2 id="_5"><strong><font style="color:rgb(0,0,0);">主动触发：</font></strong><a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">调用 runtime.GC</font></p>
<p><strong><font style="color:rgb(0,0,0);">被动触发： </font></strong></p>
<p><font style="color:rgb(0,0,0);">使用系统监控，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。 </font></p>
<p><font style="color:rgb(0,0,0);">使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例. 由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍。当 Go 新创建的对象所占用的内存大小，除以上次 GC 结束后保留下来的对象占用内存大小。 </font></p>
<h2 id="17go-gc"><font style="color:rgb(0,0,0);">17、Go 语言中 GC 的流程是什么？ </font><a class="headerlink" href="#17go-gc" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">当前版本的 Go 以 STW 为界限，可以将 GC 划分为五个阶段： </font></p>
<p><font style="color:rgb(0,0,0);">阶段说明赋值器状态 GCMark 标记准备阶段，为并发标记做准备工作，启动写屏障 STWGCMark 扫描标记阶段，与赋值器并发执行，写屏障开启并发GCMarkTermination 标记终止阶段，保证一个周期内标记任务完成，停止写屏障 STWGCoff 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭并发GCoff 内存归还阶段，将过多的内存归还给操作系统，写屏障关闭并发。</font></p>
<h2 id="18gc"><font style="color:rgb(0,0,0);">18、GC 如何调优 </font><a class="headerlink" href="#18gc" title="Permanent link">&para;</a></h2>
<p><font style="color:rgb(0,0,0);">通过 </font><code>&lt;font style="color:rgb(0,0,0);"&gt;go tool pprof&lt;/font&gt;</code><font style="color:rgb(0,0,0);"> 和 </font><code>&lt;font style="color:rgb(0,0,0);"&gt;go tool trace&lt;/font&gt;</code><font style="color:rgb(0,0,0);"> 等工具 </font></p>
<ul>
<li><font style="color:rgb(0,0,0);">控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对 CPU的利用率。 </font></li>
<li><font style="color:rgb(0,0,0);">减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。 </font></li>
<li><font style="color:rgb(0,0,0);">需要时，增大 GOGC 的值，降低 GC 的运行频率。</font></li>
</ul>
<p><font style="color:rgb(0,0,0);"></font></p>
<blockquote>
<p>更新: 2022-04-26 21:45:11<br />
原文: <a href="https://www.yuque.com/xiaoshan_wgo/codingnotes/quhuua">https://www.yuque.com/xiaoshan_wgo/codingnotes/quhuua</a></p>
</blockquote>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../../../..", "features": [], "search": "../../../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
    
    
      <script src="../../../../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>